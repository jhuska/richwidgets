// JBoss RedHat (c)
(function(a) {
    a.color = {};
    a.color.make = function(b, c, d, e) {
        var f = {};
        f.r = b || 0;
        f.g = c || 0;
        f.b = d || 0;
        f.a = e != null ? e : 1;
        f.add = function(a, b) {
            for (var c = 0; c < a.length; ++c) {
                f[a.charAt(c)] += b;
            }
            return f.normalize();
        };
        f.scale = function(a, b) {
            for (var c = 0; c < a.length; ++c) {
                f[a.charAt(c)] *= b;
            }
            return f.normalize();
        };
        f.toString = function() {
            if (f.a >= 1) {
                return "rgb(" + [ f.r, f.g, f.b ].join(",") + ")";
            } else {
                return "rgba(" + [ f.r, f.g, f.b, f.a ].join(",") + ")";
            }
        };
        f.normalize = function() {
            function a(a, b, c) {
                return b < a ? a : b > c ? c : b;
            }
            f.r = a(0, parseInt(f.r), 255);
            f.g = a(0, parseInt(f.g), 255);
            f.b = a(0, parseInt(f.b), 255);
            f.a = a(0, f.a, 1);
            return f;
        };
        f.clone = function() {
            return a.color.make(f.r, f.b, f.g, f.a);
        };
        return f.normalize();
    };
    a.color.extract = function(b, c) {
        var d;
        do {
            d = b.css(c).toLowerCase();
            if (d != "" && d != "transparent") {
                break;
            }
            b = b.parent();
        } while (!a.nodeName(b.get(0), "body"));
        if (d == "rgba(0, 0, 0, 0)") {
            d = "transparent";
        }
        return a.color.parse(d);
    };
    a.color.parse = function(c) {
        var d, e = a.color.make;
        if (d = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(c)) {
            return e(parseInt(d[1], 10), parseInt(d[2], 10), parseInt(d[3], 10));
        }
        if (d = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(c)) {
            return e(parseInt(d[1], 10), parseInt(d[2], 10), parseInt(d[3], 10), parseFloat(d[4]));
        }
        if (d = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(c)) {
            return e(parseFloat(d[1]) * 2.55, parseFloat(d[2]) * 2.55, parseFloat(d[3]) * 2.55);
        }
        if (d = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(c)) {
            return e(parseFloat(d[1]) * 2.55, parseFloat(d[2]) * 2.55, parseFloat(d[3]) * 2.55, parseFloat(d[4]));
        }
        if (d = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(c)) {
            return e(parseInt(d[1], 16), parseInt(d[2], 16), parseInt(d[3], 16));
        }
        if (d = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(c)) {
            return e(parseInt(d[1] + d[1], 16), parseInt(d[2] + d[2], 16), parseInt(d[3] + d[3], 16));
        }
        var f = a.trim(c).toLowerCase();
        if (f == "transparent") {
            return e(255, 255, 255, 0);
        } else {
            d = b[f] || [ 0, 0, 0 ];
            return e(d[0], d[1], d[2]);
        }
    };
    var b = {
        aqua: [ 0, 255, 255 ],
        azure: [ 240, 255, 255 ],
        beige: [ 245, 245, 220 ],
        black: [ 0, 0, 0 ],
        blue: [ 0, 0, 255 ],
        brown: [ 165, 42, 42 ],
        cyan: [ 0, 255, 255 ],
        darkblue: [ 0, 0, 139 ],
        darkcyan: [ 0, 139, 139 ],
        darkgrey: [ 169, 169, 169 ],
        darkgreen: [ 0, 100, 0 ],
        darkkhaki: [ 189, 183, 107 ],
        darkmagenta: [ 139, 0, 139 ],
        darkolivegreen: [ 85, 107, 47 ],
        darkorange: [ 255, 140, 0 ],
        darkorchid: [ 153, 50, 204 ],
        darkred: [ 139, 0, 0 ],
        darksalmon: [ 233, 150, 122 ],
        darkviolet: [ 148, 0, 211 ],
        fuchsia: [ 255, 0, 255 ],
        gold: [ 255, 215, 0 ],
        green: [ 0, 128, 0 ],
        indigo: [ 75, 0, 130 ],
        khaki: [ 240, 230, 140 ],
        lightblue: [ 173, 216, 230 ],
        lightcyan: [ 224, 255, 255 ],
        lightgreen: [ 144, 238, 144 ],
        lightgrey: [ 211, 211, 211 ],
        lightpink: [ 255, 182, 193 ],
        lightyellow: [ 255, 255, 224 ],
        lime: [ 0, 255, 0 ],
        magenta: [ 255, 0, 255 ],
        maroon: [ 128, 0, 0 ],
        navy: [ 0, 0, 128 ],
        olive: [ 128, 128, 0 ],
        orange: [ 255, 165, 0 ],
        pink: [ 255, 192, 203 ],
        purple: [ 128, 0, 128 ],
        violet: [ 128, 0, 128 ],
        red: [ 255, 0, 0 ],
        silver: [ 192, 192, 192 ],
        white: [ 255, 255, 255 ],
        yellow: [ 255, 255, 0 ]
    };
})(jQuery);

(function(a) {
    var b = Object.prototype.hasOwnProperty;
    function c(b, c) {
        var d = c.children("." + b)[0];
        if (d == null) {
            d = document.createElement("canvas");
            d.className = b;
            a(d).css({
                direction: "ltr",
                position: "absolute",
                left: 0,
                top: 0
            }).appendTo(c);
            if (!d.getContext) {
                if (window.G_vmlCanvasManager) {
                    d = window.G_vmlCanvasManager.initElement(d);
                } else {
                    throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.");
                }
            }
        }
        this.element = d;
        var e = this.context = d.getContext("2d");
        var f = window.devicePixelRatio || 1, g = e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1;
        this.pixelRatio = f / g;
        this.resize(c.width(), c.height());
        this.textContainer = null;
        this.text = {};
        this._textCache = {};
    }
    c.prototype.resize = function(a, b) {
        if (a <= 0 || b <= 0) {
            throw new Error("Invalid dimensions for plot, width = " + a + ", height = " + b);
        }
        var c = this.element, d = this.context, e = this.pixelRatio;
        if (this.width != a) {
            c.width = a * e;
            c.style.width = a + "px";
            this.width = a;
        }
        if (this.height != b) {
            c.height = b * e;
            c.style.height = b + "px";
            this.height = b;
        }
        d.restore();
        d.save();
        d.scale(e, e);
    };
    c.prototype.clear = function() {
        this.context.clearRect(0, 0, this.width, this.height);
    };
    c.prototype.render = function() {
        var a = this._textCache;
        for (var c in a) {
            if (b.call(a, c)) {
                var d = this.getTextLayer(c), e = a[c];
                d.hide();
                for (var f in e) {
                    if (b.call(e, f)) {
                        var g = e[f];
                        for (var h in g) {
                            if (b.call(g, h)) {
                                var i = g[h];
                                if (i.active) {
                                    if (!i.rendered) {
                                        d.append(i.element);
                                        i.rendered = true;
                                    }
                                } else {
                                    delete g[h];
                                    if (i.rendered) {
                                        i.element.detach();
                                    }
                                }
                            }
                        }
                    }
                }
                d.show();
            }
        }
    };
    c.prototype.getTextLayer = function(b) {
        var c = this.text[b];
        if (c == null) {
            if (this.textContainer == null) {
                this.textContainer = a("<div class='flot-text'></div>").css({
                    position: "absolute",
                    top: 0,
                    left: 0,
                    bottom: 0,
                    right: 0,
                    "font-size": "smaller",
                    color: "#545454"
                }).insertAfter(this.element);
            }
            c = this.text[b] = a("<div></div>").addClass(b).css({
                position: "absolute",
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
            }).appendTo(this.textContainer);
        }
        return c;
    };
    c.prototype.getTextInfo = function(b, c, d, e) {
        var f, g, h, i;
        c = "" + c;
        if (typeof d === "object") {
            f = d.style + " " + d.variant + " " + d.weight + " " + d.size + "px/" + d.lineHeight + "px " + d.family;
        } else {
            f = d;
        }
        g = this._textCache[b];
        if (g == null) {
            g = this._textCache[b] = {};
        }
        h = g[f];
        if (h == null) {
            h = g[f] = {};
        }
        i = h[c];
        if (i == null) {
            var j = a("<div></div>").html(c).css({
                position: "absolute",
                top: -9999
            }).appendTo(this.getTextLayer(b));
            if (typeof d === "object") {
                j.css({
                    font: f,
                    color: d.color
                });
            } else if (typeof d === "string") {
                j.addClass(d);
            }
            i = h[c] = {
                active: false,
                rendered: false,
                element: j,
                width: j.outerWidth(true),
                height: j.outerHeight(true)
            };
            j.detach();
        }
        return i;
    };
    c.prototype.addText = function(a, b, c, d, e, f, g, h) {
        var i = this.getTextInfo(a, d, e, f);
        i.active = true;
        if (g == "center") {
            b -= i.width / 2;
        } else if (g == "right") {
            b -= i.width;
        }
        if (h == "middle") {
            c -= i.height / 2;
        } else if (h == "bottom") {
            c -= i.height;
        }
        i.element.css({
            top: Math.round(c),
            left: Math.round(b)
        });
    };
    c.prototype.removeText = function(a, c, d, e) {
        if (c == null) {
            var f = this._textCache[a];
            if (f != null) {
                for (var g in f) {
                    if (b.call(f, g)) {
                        var h = f[g];
                        for (var i in h) {
                            if (b.call(h, i)) {
                                h[i].active = false;
                            }
                        }
                    }
                }
            }
        } else {
            this.getTextInfo(a, c, d, e).active = false;
        }
    };
    function d(b, d, f, g) {
        var h = [], i = {
            colors: [ "#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed" ],
            legend: {
                show: true,
                noColumns: 1,
                labelFormatter: null,
                labelBoxBorderColor: "#ccc",
                container: null,
                position: "ne",
                margin: 5,
                backgroundColor: null,
                backgroundOpacity: .85,
                sorted: null
            },
            xaxis: {
                show: null,
                position: "bottom",
                mode: null,
                font: null,
                color: null,
                tickColor: null,
                transform: null,
                inverseTransform: null,
                min: null,
                max: null,
                autoscaleMargin: null,
                ticks: null,
                tickFormatter: null,
                labelWidth: null,
                labelHeight: null,
                reserveSpace: null,
                tickLength: null,
                alignTicksWithAxis: null,
                tickDecimals: null,
                tickSize: null,
                minTickSize: null
            },
            yaxis: {
                autoscaleMargin: .02,
                position: "left"
            },
            xaxes: [],
            yaxes: [],
            series: {
                points: {
                    show: false,
                    radius: 3,
                    lineWidth: 2,
                    fill: true,
                    fillColor: "#ffffff",
                    symbol: "circle"
                },
                lines: {
                    lineWidth: 2,
                    fill: false,
                    fillColor: null,
                    steps: false
                },
                bars: {
                    show: false,
                    lineWidth: 2,
                    barWidth: 1,
                    fill: true,
                    fillColor: null,
                    align: "left",
                    horizontal: false,
                    zero: true
                },
                shadowSize: 3,
                highlightColor: null
            },
            grid: {
                show: true,
                aboveData: false,
                color: "#545454",
                backgroundColor: null,
                borderColor: null,
                tickColor: null,
                margin: 0,
                labelMargin: 5,
                axisMargin: 8,
                borderWidth: 2,
                minBorderMargin: null,
                markings: null,
                markingsColor: "#f4f4f4",
                markingsLineWidth: 2,
                clickable: false,
                hoverable: false,
                autoHighlight: true,
                mouseActiveRadius: 10
            },
            interaction: {
                redrawOverlayInterval: 1e3 / 60
            },
            hooks: {}
        }, j = null, k = null, l = null, m = null, n = null, o = [], p = [], q = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, r = 0, s = 0, t = {
            processOptions: [],
            processRawData: [],
            processDatapoints: [],
            processOffset: [],
            drawBackground: [],
            drawSeries: [],
            draw: [],
            bindEvents: [],
            drawOverlay: [],
            shutdown: []
        }, u = this;
        u.setData = y;
        u.setupGrid = P;
        u.draw = U;
        u.getPlaceholder = function() {
            return b;
        };
        u.getCanvas = function() {
            return j.element;
        };
        u.getPlotOffset = function() {
            return q;
        };
        u.width = function() {
            return r;
        };
        u.height = function() {
            return s;
        };
        u.offset = function() {
            var a = l.offset();
            a.left += q.left;
            a.top += q.top;
            return a;
        };
        u.getData = function() {
            return h;
        };
        u.getAxes = function() {
            var b = {}, c;
            a.each(o.concat(p), function(a, c) {
                if (c) b[c.direction + (c.n != 1 ? c.n : "") + "axis"] = c;
            });
            return b;
        };
        u.getXAxes = function() {
            return o;
        };
        u.getYAxes = function() {
            return p;
        };
        u.c2p = C;
        u.p2c = D;
        u.getOptions = function() {
            return i;
        };
        u.highlight = nb;
        u.unhighlight = ob;
        u.triggerRedrawOverlay = lb;
        u.pointOffset = function(a) {
            return {
                left: parseInt(o[A(a, "x") - 1].p2c(+a.x) + q.left, 10),
                top: parseInt(p[A(a, "y") - 1].p2c(+a.y) + q.top, 10)
            };
        };
        u.shutdown = J;
        u.resize = function() {
            var a = b.width(), c = b.height();
            j.resize(a, c);
            k.resize(a, c);
        };
        u.hooks = t;
        w(u);
        x(f);
        H();
        y(d);
        P();
        U();
        I();
        function v(a, b) {
            b = [ u ].concat(b);
            for (var c = 0; c < a.length; ++c) a[c].apply(this, b);
        }
        function w() {
            var b = {
                Canvas: c
            };
            for (var d = 0; d < g.length; ++d) {
                var e = g[d];
                e.init(u, b);
                if (e.options) a.extend(true, i, e.options);
            }
        }
        function x(c) {
            a.extend(true, i, c);
            if (i.xaxis.color == null) i.xaxis.color = a.color.parse(i.grid.color).scale("a", .22).toString();
            if (i.yaxis.color == null) i.yaxis.color = a.color.parse(i.grid.color).scale("a", .22).toString();
            if (i.xaxis.tickColor == null) i.xaxis.tickColor = i.grid.tickColor || i.xaxis.color;
            if (i.yaxis.tickColor == null) i.yaxis.tickColor = i.grid.tickColor || i.yaxis.color;
            if (i.grid.borderColor == null) i.grid.borderColor = i.grid.color;
            if (i.grid.tickColor == null) i.grid.tickColor = a.color.parse(i.grid.color).scale("a", .22).toString();
            var d, e, f, g = {
                style: b.css("font-style"),
                size: Math.round(.8 * (+b.css("font-size").replace("px", "") || 13)),
                variant: b.css("font-variant"),
                weight: b.css("font-weight"),
                family: b.css("font-family")
            };
            g.lineHeight = g.size * 1.15;
            f = i.xaxes.length || 1;
            for (d = 0; d < f; ++d) {
                e = i.xaxes[d];
                if (e && !e.tickColor) {
                    e.tickColor = e.color;
                }
                e = a.extend(true, {}, i.xaxis, e);
                i.xaxes[d] = e;
                if (e.font) {
                    e.font = a.extend({}, g, e.font);
                    if (!e.font.color) {
                        e.font.color = e.color;
                    }
                }
            }
            f = i.yaxes.length || 1;
            for (d = 0; d < f; ++d) {
                e = i.yaxes[d];
                if (e && !e.tickColor) {
                    e.tickColor = e.color;
                }
                e = a.extend(true, {}, i.yaxis, e);
                i.yaxes[d] = e;
                if (e.font) {
                    e.font = a.extend({}, g, e.font);
                    if (!e.font.color) {
                        e.font.color = e.color;
                    }
                }
            }
            if (i.xaxis.noTicks && i.xaxis.ticks == null) i.xaxis.ticks = i.xaxis.noTicks;
            if (i.yaxis.noTicks && i.yaxis.ticks == null) i.yaxis.ticks = i.yaxis.noTicks;
            if (i.x2axis) {
                i.xaxes[1] = a.extend(true, {}, i.xaxis, i.x2axis);
                i.xaxes[1].position = "top";
            }
            if (i.y2axis) {
                i.yaxes[1] = a.extend(true, {}, i.yaxis, i.y2axis);
                i.yaxes[1].position = "right";
            }
            if (i.grid.coloredAreas) i.grid.markings = i.grid.coloredAreas;
            if (i.grid.coloredAreasColor) i.grid.markingsColor = i.grid.coloredAreasColor;
            if (i.lines) a.extend(true, i.series.lines, i.lines);
            if (i.points) a.extend(true, i.series.points, i.points);
            if (i.bars) a.extend(true, i.series.bars, i.bars);
            if (i.shadowSize != null) i.series.shadowSize = i.shadowSize;
            if (i.highlightColor != null) i.series.highlightColor = i.highlightColor;
            for (d = 0; d < i.xaxes.length; ++d) E(o, d + 1).options = i.xaxes[d];
            for (d = 0; d < i.yaxes.length; ++d) E(p, d + 1).options = i.yaxes[d];
            for (var h in t) if (i.hooks[h] && i.hooks[h].length) t[h] = t[h].concat(i.hooks[h]);
            v(t.processOptions, [ i ]);
        }
        function y(a) {
            h = z(a);
            F();
            G();
        }
        function z(b) {
            var c = [];
            for (var d = 0; d < b.length; ++d) {
                var e = a.extend(true, {}, i.series);
                if (b[d].data != null) {
                    e.data = b[d].data;
                    delete b[d].data;
                    a.extend(true, e, b[d]);
                    b[d].data = e.data;
                } else e.data = b[d];
                c.push(e);
            }
            return c;
        }
        function A(a, b) {
            var c = a[b + "axis"];
            if (typeof c == "object") c = c.n;
            if (typeof c != "number") c = 1;
            return c;
        }
        function B() {
            return a.grep(o.concat(p), function(a) {
                return a;
            });
        }
        function C(a) {
            var b = {}, c, d;
            for (c = 0; c < o.length; ++c) {
                d = o[c];
                if (d && d.used) b["x" + d.n] = d.c2p(a.left);
            }
            for (c = 0; c < p.length; ++c) {
                d = p[c];
                if (d && d.used) b["y" + d.n] = d.c2p(a.top);
            }
            if (b.x1 !== undefined) b.x = b.x1;
            if (b.y1 !== undefined) b.y = b.y1;
            return b;
        }
        function D(a) {
            var b = {}, c, d, e;
            for (c = 0; c < o.length; ++c) {
                d = o[c];
                if (d && d.used) {
                    e = "x" + d.n;
                    if (a[e] == null && d.n == 1) e = "x";
                    if (a[e] != null) {
                        b.left = d.p2c(a[e]);
                        break;
                    }
                }
            }
            for (c = 0; c < p.length; ++c) {
                d = p[c];
                if (d && d.used) {
                    e = "y" + d.n;
                    if (a[e] == null && d.n == 1) e = "y";
                    if (a[e] != null) {
                        b.top = d.p2c(a[e]);
                        break;
                    }
                }
            }
            return b;
        }
        function E(b, c) {
            if (!b[c - 1]) b[c - 1] = {
                n: c,
                direction: b == o ? "x" : "y",
                options: a.extend(true, {}, b == o ? i.xaxis : i.yaxis)
            };
            return b[c - 1];
        }
        function F() {
            var b = h.length, c = -1, d;
            for (d = 0; d < h.length; ++d) {
                var e = h[d].color;
                if (e != null) {
                    b--;
                    if (typeof e == "number" && e > c) {
                        c = e;
                    }
                }
            }
            if (b <= c) {
                b = c + 1;
            }
            var f, g = [], j = i.colors, k = j.length, l = 0;
            for (d = 0; d < b; d++) {
                f = a.color.parse(j[d % k] || "#666");
                if (d % k == 0 && d) {
                    if (l >= 0) {
                        if (l < .5) {
                            l = -l - .2;
                        } else l = 0;
                    } else l = -l;
                }
                g[d] = f.scale("rgb", 1 + l);
            }
            var m = 0, n;
            for (d = 0; d < h.length; ++d) {
                n = h[d];
                if (n.color == null) {
                    n.color = g[m].toString();
                    ++m;
                } else if (typeof n.color == "number") n.color = g[n.color].toString();
                if (n.lines.show == null) {
                    var q, r = true;
                    for (q in n) if (n[q] && n[q].show) {
                        r = false;
                        break;
                    }
                    if (r) n.lines.show = true;
                }
                if (n.lines.zero == null) {
                    n.lines.zero = !!n.lines.fill;
                }
                n.xaxis = E(o, A(n, "x"));
                n.yaxis = E(p, A(n, "y"));
            }
        }
        function G() {
            var b = Number.POSITIVE_INFINITY, c = Number.NEGATIVE_INFINITY, d = Number.MAX_VALUE, e, f, g, i, j, k, l, m, n, o, p, q, r, s, u, w;
            function x(a, b, c) {
                if (b < a.datamin && b != -d) a.datamin = b;
                if (c > a.datamax && c != d) a.datamax = c;
            }
            a.each(B(), function(a, d) {
                d.datamin = b;
                d.datamax = c;
                d.used = false;
            });
            for (e = 0; e < h.length; ++e) {
                k = h[e];
                k.datapoints = {
                    points: []
                };
                v(t.processRawData, [ k, k.data, k.datapoints ]);
            }
            for (e = 0; e < h.length; ++e) {
                k = h[e];
                u = k.data;
                w = k.datapoints.format;
                if (!w) {
                    w = [];
                    w.push({
                        x: true,
                        number: true,
                        required: true
                    });
                    w.push({
                        y: true,
                        number: true,
                        required: true
                    });
                    if (k.bars.show || k.lines.show && k.lines.fill) {
                        var y = !!(k.bars.show && k.bars.zero || k.lines.show && k.lines.zero);
                        w.push({
                            y: true,
                            number: true,
                            required: false,
                            defaultValue: 0,
                            autoscale: y
                        });
                        if (k.bars.horizontal) {
                            delete w[w.length - 1].y;
                            w[w.length - 1].x = true;
                        }
                    }
                    k.datapoints.format = w;
                }
                if (k.datapoints.pointsize != null) continue;
                k.datapoints.pointsize = w.length;
                m = k.datapoints.pointsize;
                l = k.datapoints.points;
                var z = k.lines.show && k.lines.steps;
                k.xaxis.used = k.yaxis.used = true;
                for (f = g = 0; f < u.length; ++f, g += m) {
                    s = u[f];
                    var A = s == null;
                    if (!A) {
                        for (i = 0; i < m; ++i) {
                            q = s[i];
                            r = w[i];
                            if (r) {
                                if (r.number && q != null) {
                                    q = +q;
                                    if (isNaN(q)) q = null; else if (q == Infinity) q = d; else if (q == -Infinity) q = -d;
                                }
                                if (q == null) {
                                    if (r.required) A = true;
                                    if (r.defaultValue != null) q = r.defaultValue;
                                }
                            }
                            l[g + i] = q;
                        }
                    }
                    if (A) {
                        for (i = 0; i < m; ++i) {
                            q = l[g + i];
                            if (q != null) {
                                r = w[i];
                                if (r.x) x(k.xaxis, q, q);
                                if (r.y) x(k.yaxis, q, q);
                            }
                            l[g + i] = null;
                        }
                    } else {
                        if (z && g > 0 && l[g - m] != null && l[g - m] != l[g] && l[g - m + 1] != l[g + 1]) {
                            for (i = 0; i < m; ++i) l[g + m + i] = l[g + i];
                            l[g + 1] = l[g - m + 1];
                            g += m;
                        }
                    }
                }
            }
            for (e = 0; e < h.length; ++e) {
                k = h[e];
                v(t.processDatapoints, [ k, k.datapoints ]);
            }
            for (e = 0; e < h.length; ++e) {
                k = h[e];
                l = k.datapoints.points, m = k.datapoints.pointsize;
                w = k.datapoints.format;
                var C = b, D = b, E = c, F = c;
                for (f = 0; f < l.length; f += m) {
                    if (l[f] == null) continue;
                    for (i = 0; i < m; ++i) {
                        q = l[f + i];
                        r = w[i];
                        if (!r || r.autoscale === false || q == d || q == -d) continue;
                        if (r.x) {
                            if (q < C) C = q;
                            if (q > E) E = q;
                        }
                        if (r.y) {
                            if (q < D) D = q;
                            if (q > F) F = q;
                        }
                    }
                }
                if (k.bars.show) {
                    var G;
                    switch (k.bars.align) {
                      case "left":
                        G = 0;
                        break;

                      case "right":
                        G = -k.bars.barWidth;
                        break;

                      case "center":
                        G = -k.bars.barWidth / 2;
                        break;

                      default:
                        throw new Error("Invalid bar alignment: " + k.bars.align);
                    }
                    if (k.bars.horizontal) {
                        D += G;
                        F += G + k.bars.barWidth;
                    } else {
                        C += G;
                        E += G + k.bars.barWidth;
                    }
                }
                x(k.xaxis, C, E);
                x(k.yaxis, D, F);
            }
            a.each(B(), function(a, d) {
                if (d.datamin == b) d.datamin = null;
                if (d.datamax == c) d.datamax = null;
            });
        }
        function H() {
            b.css("padding", 0).children(":not(.flot-base,.flot-overlay)").remove();
            if (b.css("position") == "static") b.css("position", "relative");
            j = new c("flot-base", b);
            k = new c("flot-overlay", b);
            m = j.context;
            n = k.context;
            l = a(k.element).unbind();
            var d = b.data("plot");
            if (d) {
                d.shutdown();
                k.clear();
            }
            b.data("plot", u);
        }
        function I() {
            if (i.grid.hoverable) {
                l.mousemove(hb);
                l.bind("mouseleave", ib);
            }
            if (i.grid.clickable) l.click(jb);
            v(t.bindEvents, [ l ]);
        }
        function J() {
            if (fb) clearTimeout(fb);
            l.unbind("mousemove", hb);
            l.unbind("mouseleave", ib);
            l.unbind("click", jb);
            v(t.shutdown, [ l ]);
        }
        function K(a) {
            function b(a) {
                return a;
            }
            var c, d, e = a.options.transform || b, f = a.options.inverseTransform;
            if (a.direction == "x") {
                c = a.scale = r / Math.abs(e(a.max) - e(a.min));
                d = Math.min(e(a.max), e(a.min));
            } else {
                c = a.scale = s / Math.abs(e(a.max) - e(a.min));
                c = -c;
                d = Math.max(e(a.max), e(a.min));
            }
            if (e == b) a.p2c = function(a) {
                return (a - d) * c;
            }; else a.p2c = function(a) {
                return (e(a) - d) * c;
            };
            if (!f) a.c2p = function(a) {
                return d + a / c;
            }; else a.c2p = function(a) {
                return f(d + a / c);
            };
        }
        function L(a) {
            var b = a.options, c = a.ticks || [], d = b.labelWidth || 0, e = b.labelHeight || 0, f = a.direction + "Axis " + a.direction + a.n + "Axis", g = "flot-" + a.direction + "-axis flot-" + a.direction + a.n + "-axis " + f, h = b.font || "flot-tick-label tickLabel";
            for (var i = 0; i < c.length; ++i) {
                var k = c[i];
                if (!k.label) continue;
                var l = j.getTextInfo(g, k.label, h);
                if (b.labelWidth == null) d = Math.max(d, l.width);
                if (b.labelHeight == null) e = Math.max(e, l.height);
            }
            a.labelWidth = Math.ceil(d);
            a.labelHeight = Math.ceil(e);
        }
        function M(b) {
            var c = b.labelWidth, d = b.labelHeight, e = b.options.position, f = b.options.tickLength, g = i.grid.axisMargin, h = i.grid.labelMargin, k = b.direction == "x" ? o : p, l, m;
            var n = a.grep(k, function(a) {
                return a && a.options.position == e && a.reserveSpace;
            });
            if (a.inArray(b, n) == n.length - 1) g = 0;
            if (f == null) {
                var r = a.grep(k, function(a) {
                    return a && a.reserveSpace;
                });
                m = a.inArray(b, r) == 0;
                if (m) f = "full"; else f = 5;
            }
            if (!isNaN(+f)) h += +f;
            if (b.direction == "x") {
                d += h;
                if (e == "bottom") {
                    q.bottom += d + g;
                    b.box = {
                        top: j.height - q.bottom,
                        height: d
                    };
                } else {
                    b.box = {
                        top: q.top + g,
                        height: d
                    };
                    q.top += d + g;
                }
            } else {
                c += h;
                if (e == "left") {
                    b.box = {
                        left: q.left + g,
                        width: c
                    };
                    q.left += c + g;
                } else {
                    q.right += c + g;
                    b.box = {
                        left: j.width - q.right,
                        width: c
                    };
                }
            }
            b.position = e;
            b.tickLength = f;
            b.box.padding = h;
            b.innermost = m;
        }
        function N(a) {
            if (a.direction == "x") {
                a.box.left = q.left - a.labelWidth / 2;
                a.box.width = j.width - q.left - q.right + a.labelWidth;
            } else {
                a.box.top = q.top - a.labelHeight / 2;
                a.box.height = j.height - q.bottom - q.top + a.labelHeight;
            }
        }
        function O() {
            var b = i.grid.minBorderMargin, c = {
                x: 0,
                y: 0
            }, d, e;
            if (b == null) {
                b = 0;
                for (d = 0; d < h.length; ++d) b = Math.max(b, 2 * (h[d].points.radius + h[d].points.lineWidth / 2));
            }
            c.x = c.y = Math.ceil(b);
            a.each(B(), function(a, b) {
                var d = b.direction;
                if (b.reserveSpace) c[d] = Math.ceil(Math.max(c[d], (d == "x" ? b.labelWidth : b.labelHeight) / 2));
            });
            q.left = Math.max(c.x, q.left);
            q.right = Math.max(c.x, q.right);
            q.top = Math.max(c.y, q.top);
            q.bottom = Math.max(c.y, q.bottom);
        }
        function P() {
            var b, c = B(), d = i.grid.show;
            for (var e in q) {
                var f = i.grid.margin || 0;
                q[e] = typeof f == "number" ? f : f[e] || 0;
            }
            v(t.processOffset, [ q ]);
            for (var e in q) {
                if (typeof i.grid.borderWidth == "object") {
                    q[e] += d ? i.grid.borderWidth[e] : 0;
                } else {
                    q[e] += d ? i.grid.borderWidth : 0;
                }
            }
            a.each(c, function(a, b) {
                b.show = b.options.show;
                if (b.show == null) b.show = b.used;
                b.reserveSpace = b.show || b.options.reserveSpace;
                Q(b);
            });
            if (d) {
                var g = a.grep(c, function(a) {
                    return a.reserveSpace;
                });
                a.each(g, function(a, b) {
                    R(b);
                    S(b);
                    T(b, b.ticks);
                    L(b);
                });
                for (b = g.length - 1; b >= 0; --b) M(g[b]);
                O();
                a.each(g, function(a, b) {
                    N(b);
                });
            }
            r = j.width - q.left - q.right;
            s = j.height - q.bottom - q.top;
            a.each(c, function(a, b) {
                K(b);
            });
            if (d) {
                Y();
            }
            db();
        }
        function Q(a) {
            var b = a.options, c = +(b.min != null ? b.min : a.datamin), d = +(b.max != null ? b.max : a.datamax), e = d - c;
            if (e == 0) {
                var f = d == 0 ? 1 : .01;
                if (b.min == null) c -= f;
                if (b.max == null || b.min != null) d += f;
            } else {
                var g = b.autoscaleMargin;
                if (g != null) {
                    if (b.min == null) {
                        c -= e * g;
                        if (c < 0 && a.datamin != null && a.datamin >= 0) c = 0;
                    }
                    if (b.max == null) {
                        d += e * g;
                        if (d > 0 && a.datamax != null && a.datamax <= 0) d = 0;
                    }
                }
            }
            a.min = c;
            a.max = d;
        }
        function R(b) {
            var c = b.options;
            var d;
            if (typeof c.ticks == "number" && c.ticks > 0) d = c.ticks; else d = .3 * Math.sqrt(b.direction == "x" ? j.width : j.height);
            var f = (b.max - b.min) / d, g = -Math.floor(Math.log(f) / Math.LN10), h = c.tickDecimals;
            if (h != null && g > h) {
                g = h;
            }
            var i = Math.pow(10, -g), k = f / i, l;
            if (k < 1.5) {
                l = 1;
            } else if (k < 3) {
                l = 2;
                if (k > 2.25 && (h == null || g + 1 <= h)) {
                    l = 2.5;
                    ++g;
                }
            } else if (k < 7.5) {
                l = 5;
            } else {
                l = 10;
            }
            l *= i;
            if (c.minTickSize != null && l < c.minTickSize) {
                l = c.minTickSize;
            }
            b.delta = f;
            b.tickDecimals = Math.max(0, h != null ? h : g);
            b.tickSize = c.tickSize || l;
            if (c.mode == "time" && !b.tickGenerator) {
                throw new Error("Time mode requires the flot.time plugin.");
            }
            if (!b.tickGenerator) {
                b.tickGenerator = function(a) {
                    var b = [], c = e(a.min, a.tickSize), d = 0, f = Number.NaN, g;
                    do {
                        g = f;
                        f = c + d * a.tickSize;
                        b.push(f);
                        ++d;
                    } while (f < a.max && f != g);
                    return b;
                };
                b.tickFormatter = function(a, b) {
                    var c = b.tickDecimals ? Math.pow(10, b.tickDecimals) : 1;
                    var d = "" + Math.round(a * c) / c;
                    if (b.tickDecimals != null) {
                        var e = d.indexOf(".");
                        var f = e == -1 ? 0 : d.length - e - 1;
                        if (f < b.tickDecimals) {
                            return (f ? d : d + ".") + ("" + c).substr(1, b.tickDecimals - f);
                        }
                    }
                    return d;
                };
            }
            if (a.isFunction(c.tickFormatter)) b.tickFormatter = function(a, b) {
                return "" + c.tickFormatter(a, b);
            };
            if (c.alignTicksWithAxis != null) {
                var m = (b.direction == "x" ? o : p)[c.alignTicksWithAxis - 1];
                if (m && m.used && m != b) {
                    var n = b.tickGenerator(b);
                    if (n.length > 0) {
                        if (c.min == null) b.min = Math.min(b.min, n[0]);
                        if (c.max == null && n.length > 1) b.max = Math.max(b.max, n[n.length - 1]);
                    }
                    b.tickGenerator = function(a) {
                        var b = [], c, d;
                        for (d = 0; d < m.ticks.length; ++d) {
                            c = (m.ticks[d].v - m.min) / (m.max - m.min);
                            c = a.min + c * (a.max - a.min);
                            b.push(c);
                        }
                        return b;
                    };
                    if (!b.mode && c.tickDecimals == null) {
                        var q = Math.max(0, -Math.floor(Math.log(b.delta) / Math.LN10) + 1), r = b.tickGenerator(b);
                        if (!(r.length > 1 && /\..*0$/.test((r[1] - r[0]).toFixed(q)))) b.tickDecimals = q;
                    }
                }
            }
        }
        function S(b) {
            var c = b.options.ticks, d = [];
            if (c == null || typeof c == "number" && c > 0) d = b.tickGenerator(b); else if (c) {
                if (a.isFunction(c)) d = c(b); else d = c;
            }
            var e, f;
            b.ticks = [];
            for (e = 0; e < d.length; ++e) {
                var g = null;
                var h = d[e];
                if (typeof h == "object") {
                    f = +h[0];
                    if (h.length > 1) g = h[1];
                } else f = +h;
                if (g == null) g = b.tickFormatter(f, b);
                if (!isNaN(f)) b.ticks.push({
                    v: f,
                    label: g
                });
            }
        }
        function T(a, b) {
            if (a.options.autoscaleMargin && b.length > 0) {
                if (a.options.min == null) a.min = Math.min(a.min, b[0].v);
                if (a.options.max == null && b.length > 1) a.max = Math.max(a.max, b[b.length - 1].v);
            }
        }
        function U() {
            j.clear();
            v(t.drawBackground, [ m ]);
            var a = i.grid;
            if (a.show && a.backgroundColor) W();
            if (a.show && !a.aboveData) {
                X();
            }
            for (var b = 0; b < h.length; ++b) {
                v(t.drawSeries, [ m, h[b] ]);
                Z(h[b]);
            }
            v(t.draw, [ m ]);
            if (a.show && a.aboveData) {
                X();
            }
            j.render();
        }
        function V(a, b) {
            var c, d, e, f, g = B();
            for (var h = 0; h < g.length; ++h) {
                c = g[h];
                if (c.direction == b) {
                    f = b + c.n + "axis";
                    if (!a[f] && c.n == 1) f = b + "axis";
                    if (a[f]) {
                        d = a[f].from;
                        e = a[f].to;
                        break;
                    }
                }
            }
            if (!a[f]) {
                c = b == "x" ? o[0] : p[0];
                d = a[b + "1"];
                e = a[b + "2"];
            }
            if (d != null && e != null && d > e) {
                var i = d;
                d = e;
                e = i;
            }
            return {
                from: d,
                to: e,
                axis: c
            };
        }
        function W() {
            m.save();
            m.translate(q.left, q.top);
            m.fillStyle = sb(i.grid.backgroundColor, s, 0, "rgba(255, 255, 255, 0)");
            m.fillRect(0, 0, r, s);
            m.restore();
        }
        function X() {
            var b, c, d, e;
            m.save();
            m.translate(q.left, q.top);
            var f = i.grid.markings;
            if (f) {
                if (a.isFunction(f)) {
                    c = u.getAxes();
                    c.xmin = c.xaxis.min;
                    c.xmax = c.xaxis.max;
                    c.ymin = c.yaxis.min;
                    c.ymax = c.yaxis.max;
                    f = f(c);
                }
                for (b = 0; b < f.length; ++b) {
                    var g = f[b], h = V(g, "x"), j = V(g, "y");
                    if (h.from == null) h.from = h.axis.min;
                    if (h.to == null) h.to = h.axis.max;
                    if (j.from == null) j.from = j.axis.min;
                    if (j.to == null) j.to = j.axis.max;
                    if (h.to < h.axis.min || h.from > h.axis.max || j.to < j.axis.min || j.from > j.axis.max) continue;
                    h.from = Math.max(h.from, h.axis.min);
                    h.to = Math.min(h.to, h.axis.max);
                    j.from = Math.max(j.from, j.axis.min);
                    j.to = Math.min(j.to, j.axis.max);
                    if (h.from == h.to && j.from == j.to) continue;
                    h.from = h.axis.p2c(h.from);
                    h.to = h.axis.p2c(h.to);
                    j.from = j.axis.p2c(j.from);
                    j.to = j.axis.p2c(j.to);
                    if (h.from == h.to || j.from == j.to) {
                        m.beginPath();
                        m.strokeStyle = g.color || i.grid.markingsColor;
                        m.lineWidth = g.lineWidth || i.grid.markingsLineWidth;
                        m.moveTo(h.from, j.from);
                        m.lineTo(h.to, j.to);
                        m.stroke();
                    } else {
                        m.fillStyle = g.color || i.grid.markingsColor;
                        m.fillRect(h.from, j.to, h.to - h.from, j.from - j.to);
                    }
                }
            }
            c = B();
            d = i.grid.borderWidth;
            for (var k = 0; k < c.length; ++k) {
                var l = c[k], n = l.box, o = l.tickLength, p, t, v, w;
                if (!l.show || l.ticks.length == 0) continue;
                m.lineWidth = 1;
                if (l.direction == "x") {
                    p = 0;
                    if (o == "full") t = l.position == "top" ? 0 : s; else t = n.top - q.top + (l.position == "top" ? n.height : 0);
                } else {
                    t = 0;
                    if (o == "full") p = l.position == "left" ? 0 : r; else p = n.left - q.left + (l.position == "left" ? n.width : 0);
                }
                if (!l.innermost) {
                    m.strokeStyle = l.options.color;
                    m.beginPath();
                    v = w = 0;
                    if (l.direction == "x") v = r + 1; else w = s + 1;
                    if (m.lineWidth == 1) {
                        if (l.direction == "x") {
                            t = Math.floor(t) + .5;
                        } else {
                            p = Math.floor(p) + .5;
                        }
                    }
                    m.moveTo(p, t);
                    m.lineTo(p + v, t + w);
                    m.stroke();
                }
                m.strokeStyle = l.options.tickColor;
                m.beginPath();
                for (b = 0; b < l.ticks.length; ++b) {
                    var x = l.ticks[b].v;
                    v = w = 0;
                    if (isNaN(x) || x < l.min || x > l.max || o == "full" && (typeof d == "object" && d[l.position] > 0 || d > 0) && (x == l.min || x == l.max)) continue;
                    if (l.direction == "x") {
                        p = l.p2c(x);
                        w = o == "full" ? -s : o;
                        if (l.position == "top") w = -w;
                    } else {
                        t = l.p2c(x);
                        v = o == "full" ? -r : o;
                        if (l.position == "left") v = -v;
                    }
                    if (m.lineWidth == 1) {
                        if (l.direction == "x") p = Math.floor(p) + .5; else t = Math.floor(t) + .5;
                    }
                    m.moveTo(p, t);
                    m.lineTo(p + v, t + w);
                }
                m.stroke();
            }
            if (d) {
                e = i.grid.borderColor;
                if (typeof d == "object" || typeof e == "object") {
                    if (typeof d !== "object") {
                        d = {
                            top: d,
                            right: d,
                            bottom: d,
                            left: d
                        };
                    }
                    if (typeof e !== "object") {
                        e = {
                            top: e,
                            right: e,
                            bottom: e,
                            left: e
                        };
                    }
                    if (d.top > 0) {
                        m.strokeStyle = e.top;
                        m.lineWidth = d.top;
                        m.beginPath();
                        m.moveTo(0 - d.left, 0 - d.top / 2);
                        m.lineTo(r, 0 - d.top / 2);
                        m.stroke();
                    }
                    if (d.right > 0) {
                        m.strokeStyle = e.right;
                        m.lineWidth = d.right;
                        m.beginPath();
                        m.moveTo(r + d.right / 2, 0 - d.top);
                        m.lineTo(r + d.right / 2, s);
                        m.stroke();
                    }
                    if (d.bottom > 0) {
                        m.strokeStyle = e.bottom;
                        m.lineWidth = d.bottom;
                        m.beginPath();
                        m.moveTo(r + d.right, s + d.bottom / 2);
                        m.lineTo(0, s + d.bottom / 2);
                        m.stroke();
                    }
                    if (d.left > 0) {
                        m.strokeStyle = e.left;
                        m.lineWidth = d.left;
                        m.beginPath();
                        m.moveTo(0 - d.left / 2, s + d.bottom);
                        m.lineTo(0 - d.left / 2, 0);
                        m.stroke();
                    }
                } else {
                    m.lineWidth = d;
                    m.strokeStyle = i.grid.borderColor;
                    m.strokeRect(-d / 2, -d / 2, r + d, s + d);
                }
            }
            m.restore();
        }
        function Y() {
            a.each(B(), function(a, b) {
                if (!b.show || b.ticks.length == 0) return;
                var c = b.box, d = b.direction + "Axis " + b.direction + b.n + "Axis", e = "flot-" + b.direction + "-axis flot-" + b.direction + b.n + "-axis " + d, f = b.options.font || "flot-tick-label tickLabel", g, h, i, k, l;
                j.removeText(e);
                for (var m = 0; m < b.ticks.length; ++m) {
                    g = b.ticks[m];
                    if (!g.label || g.v < b.min || g.v > b.max) continue;
                    if (b.direction == "x") {
                        k = "center";
                        h = q.left + b.p2c(g.v);
                        if (b.position == "bottom") {
                            i = c.top + c.padding;
                        } else {
                            i = c.top + c.height - c.padding;
                            l = "bottom";
                        }
                    } else {
                        l = "middle";
                        i = q.top + b.p2c(g.v);
                        if (b.position == "left") {
                            h = c.left + c.width - c.padding;
                            k = "right";
                        } else {
                            h = c.left + c.padding;
                        }
                    }
                    j.addText(e, h, i, g.label, f, null, k, l);
                }
            });
        }
        function Z(a) {
            if (a.lines.show) $(a);
            if (a.bars.show) bb(a);
            if (a.points.show) _(a);
        }
        function $(a) {
            function b(a, b, c, d, e) {
                var f = a.points, g = a.pointsize, h = null, i = null;
                m.beginPath();
                for (var j = g; j < f.length; j += g) {
                    var k = f[j - g], l = f[j - g + 1], n = f[j], o = f[j + 1];
                    if (k == null || n == null) continue;
                    if (l <= o && l < e.min) {
                        if (o < e.min) continue;
                        k = (e.min - l) / (o - l) * (n - k) + k;
                        l = e.min;
                    } else if (o <= l && o < e.min) {
                        if (l < e.min) continue;
                        n = (e.min - l) / (o - l) * (n - k) + k;
                        o = e.min;
                    }
                    if (l >= o && l > e.max) {
                        if (o > e.max) continue;
                        k = (e.max - l) / (o - l) * (n - k) + k;
                        l = e.max;
                    } else if (o >= l && o > e.max) {
                        if (l > e.max) continue;
                        n = (e.max - l) / (o - l) * (n - k) + k;
                        o = e.max;
                    }
                    if (k <= n && k < d.min) {
                        if (n < d.min) continue;
                        l = (d.min - k) / (n - k) * (o - l) + l;
                        k = d.min;
                    } else if (n <= k && n < d.min) {
                        if (k < d.min) continue;
                        o = (d.min - k) / (n - k) * (o - l) + l;
                        n = d.min;
                    }
                    if (k >= n && k > d.max) {
                        if (n > d.max) continue;
                        l = (d.max - k) / (n - k) * (o - l) + l;
                        k = d.max;
                    } else if (n >= k && n > d.max) {
                        if (k > d.max) continue;
                        o = (d.max - k) / (n - k) * (o - l) + l;
                        n = d.max;
                    }
                    if (k != h || l != i) m.moveTo(d.p2c(k) + b, e.p2c(l) + c);
                    h = n;
                    i = o;
                    m.lineTo(d.p2c(n) + b, e.p2c(o) + c);
                }
                m.stroke();
            }
            function c(a, b, c) {
                var d = a.points, e = a.pointsize, f = Math.min(Math.max(0, c.min), c.max), g = 0, h, i = false, j = 1, k = 0, l = 0;
                while (true) {
                    if (e > 0 && g > d.length + e) break;
                    g += e;
                    var n = d[g - e], o = d[g - e + j], p = d[g], q = d[g + j];
                    if (i) {
                        if (e > 0 && n != null && p == null) {
                            l = g;
                            e = -e;
                            j = 2;
                            continue;
                        }
                        if (e < 0 && g == k + e) {
                            m.fill();
                            i = false;
                            e = -e;
                            j = 1;
                            g = k = l + e;
                            continue;
                        }
                    }
                    if (n == null || p == null) continue;
                    if (n <= p && n < b.min) {
                        if (p < b.min) continue;
                        o = (b.min - n) / (p - n) * (q - o) + o;
                        n = b.min;
                    } else if (p <= n && p < b.min) {
                        if (n < b.min) continue;
                        q = (b.min - n) / (p - n) * (q - o) + o;
                        p = b.min;
                    }
                    if (n >= p && n > b.max) {
                        if (p > b.max) continue;
                        o = (b.max - n) / (p - n) * (q - o) + o;
                        n = b.max;
                    } else if (p >= n && p > b.max) {
                        if (n > b.max) continue;
                        q = (b.max - n) / (p - n) * (q - o) + o;
                        p = b.max;
                    }
                    if (!i) {
                        m.beginPath();
                        m.moveTo(b.p2c(n), c.p2c(f));
                        i = true;
                    }
                    if (o >= c.max && q >= c.max) {
                        m.lineTo(b.p2c(n), c.p2c(c.max));
                        m.lineTo(b.p2c(p), c.p2c(c.max));
                        continue;
                    } else if (o <= c.min && q <= c.min) {
                        m.lineTo(b.p2c(n), c.p2c(c.min));
                        m.lineTo(b.p2c(p), c.p2c(c.min));
                        continue;
                    }
                    var r = n, s = p;
                    if (o <= q && o < c.min && q >= c.min) {
                        n = (c.min - o) / (q - o) * (p - n) + n;
                        o = c.min;
                    } else if (q <= o && q < c.min && o >= c.min) {
                        p = (c.min - o) / (q - o) * (p - n) + n;
                        q = c.min;
                    }
                    if (o >= q && o > c.max && q <= c.max) {
                        n = (c.max - o) / (q - o) * (p - n) + n;
                        o = c.max;
                    } else if (q >= o && q > c.max && o <= c.max) {
                        p = (c.max - o) / (q - o) * (p - n) + n;
                        q = c.max;
                    }
                    if (n != r) {
                        m.lineTo(b.p2c(r), c.p2c(o));
                    }
                    m.lineTo(b.p2c(n), c.p2c(o));
                    m.lineTo(b.p2c(p), c.p2c(q));
                    if (p != s) {
                        m.lineTo(b.p2c(p), c.p2c(q));
                        m.lineTo(b.p2c(s), c.p2c(q));
                    }
                }
            }
            m.save();
            m.translate(q.left, q.top);
            m.lineJoin = "round";
            var d = a.lines.lineWidth, e = a.shadowSize;
            if (d > 0 && e > 0) {
                m.lineWidth = e;
                m.strokeStyle = "rgba(0,0,0,0.1)";
                var f = Math.PI / 18;
                b(a.datapoints, Math.sin(f) * (d / 2 + e / 2), Math.cos(f) * (d / 2 + e / 2), a.xaxis, a.yaxis);
                m.lineWidth = e / 2;
                b(a.datapoints, Math.sin(f) * (d / 2 + e / 4), Math.cos(f) * (d / 2 + e / 4), a.xaxis, a.yaxis);
            }
            m.lineWidth = d;
            m.strokeStyle = a.color;
            var g = cb(a.lines, a.color, 0, s);
            if (g) {
                m.fillStyle = g;
                c(a.datapoints, a.xaxis, a.yaxis);
            }
            if (d > 0) b(a.datapoints, 0, 0, a.xaxis, a.yaxis);
            m.restore();
        }
        function _(a) {
            function b(a, b, c, d, e, f, g, h) {
                var i = a.points, j = a.pointsize;
                for (var k = 0; k < i.length; k += j) {
                    var l = i[k], n = i[k + 1];
                    if (l == null || l < f.min || l > f.max || n < g.min || n > g.max) continue;
                    m.beginPath();
                    l = f.p2c(l);
                    n = g.p2c(n) + d;
                    if (h == "circle") m.arc(l, n, b, 0, e ? Math.PI : Math.PI * 2, false); else h(m, l, n, b, e);
                    m.closePath();
                    if (c) {
                        m.fillStyle = c;
                        m.fill();
                    }
                    m.stroke();
                }
            }
            m.save();
            m.translate(q.left, q.top);
            var c = a.points.lineWidth, d = a.shadowSize, e = a.points.radius, f = a.points.symbol;
            if (c == 0) c = 1e-4;
            if (c > 0 && d > 0) {
                var g = d / 2;
                m.lineWidth = g;
                m.strokeStyle = "rgba(0,0,0,0.1)";
                b(a.datapoints, e, null, g + g / 2, true, a.xaxis, a.yaxis, f);
                m.strokeStyle = "rgba(0,0,0,0.2)";
                b(a.datapoints, e, null, g / 2, true, a.xaxis, a.yaxis, f);
            }
            m.lineWidth = c;
            m.strokeStyle = a.color;
            b(a.datapoints, e, cb(a.points, a.color), 0, false, a.xaxis, a.yaxis, f);
            m.restore();
        }
        function ab(a, b, c, d, e, f, g, h, i, j, k, l) {
            var m, n, o, p, q, r, s, t, u;
            if (k) {
                t = r = s = true;
                q = false;
                m = c;
                n = a;
                p = b + d;
                o = b + e;
                if (n < m) {
                    u = n;
                    n = m;
                    m = u;
                    q = true;
                    r = false;
                }
            } else {
                q = r = s = true;
                t = false;
                m = a + d;
                n = a + e;
                o = c;
                p = b;
                if (p < o) {
                    u = p;
                    p = o;
                    o = u;
                    t = true;
                    s = false;
                }
            }
            if (n < h.min || m > h.max || p < i.min || o > i.max) return;
            if (m < h.min) {
                m = h.min;
                q = false;
            }
            if (n > h.max) {
                n = h.max;
                r = false;
            }
            if (o < i.min) {
                o = i.min;
                t = false;
            }
            if (p > i.max) {
                p = i.max;
                s = false;
            }
            m = h.p2c(m);
            o = i.p2c(o);
            n = h.p2c(n);
            p = i.p2c(p);
            if (g) {
                j.beginPath();
                j.moveTo(m, o);
                j.lineTo(m, p);
                j.lineTo(n, p);
                j.lineTo(n, o);
                j.fillStyle = g(o, p);
                j.fill();
            }
            if (l > 0 && (q || r || s || t)) {
                j.beginPath();
                j.moveTo(m, o + f);
                if (q) j.lineTo(m, p + f); else j.moveTo(m, p + f);
                if (s) j.lineTo(n, p + f); else j.moveTo(n, p + f);
                if (r) j.lineTo(n, o + f); else j.moveTo(n, o + f);
                if (t) j.lineTo(m, o + f); else j.moveTo(m, o + f);
                j.stroke();
            }
        }
        function bb(a) {
            function b(b, c, d, e, f, g, h) {
                var i = b.points, j = b.pointsize;
                for (var k = 0; k < i.length; k += j) {
                    if (i[k] == null) continue;
                    ab(i[k], i[k + 1], i[k + 2], c, d, e, f, g, h, m, a.bars.horizontal, a.bars.lineWidth);
                }
            }
            m.save();
            m.translate(q.left, q.top);
            m.lineWidth = a.bars.lineWidth;
            m.strokeStyle = a.color;
            var c;
            switch (a.bars.align) {
              case "left":
                c = 0;
                break;

              case "right":
                c = -a.bars.barWidth;
                break;

              case "center":
                c = -a.bars.barWidth / 2;
                break;

              default:
                throw new Error("Invalid bar alignment: " + a.bars.align);
            }
            var d = a.bars.fill ? function(b, c) {
                return cb(a.bars, a.color, b, c);
            } : null;
            b(a.datapoints, c, c + a.bars.barWidth, 0, d, a.xaxis, a.yaxis);
            m.restore();
        }
        function cb(b, c, d, e) {
            var f = b.fill;
            if (!f) return null;
            if (b.fillColor) return sb(b.fillColor, d, e, c);
            var g = a.color.parse(c);
            g.a = typeof f == "number" ? f : .4;
            g.normalize();
            return g.toString();
        }
        function db() {
            b.find(".legend").remove();
            if (!i.legend.show) return;
            var c = [], d = [], e = false, f = i.legend.labelFormatter, g, j;
            for (var k = 0; k < h.length; ++k) {
                g = h[k];
                if (g.label) {
                    j = f ? f(g.label, g) : g.label;
                    if (j) {
                        d.push({
                            label: j,
                            color: g.color
                        });
                    }
                }
            }
            if (i.legend.sorted) {
                if (a.isFunction(i.legend.sorted)) {
                    d.sort(i.legend.sorted);
                } else if (i.legend.sorted == "reverse") {
                    d.reverse();
                } else {
                    var l = i.legend.sorted != "descending";
                    d.sort(function(a, b) {
                        return a.label == b.label ? 0 : a.label < b.label != l ? 1 : -1;
                    });
                }
            }
            for (var k = 0; k < d.length; ++k) {
                var m = d[k];
                if (k % i.legend.noColumns == 0) {
                    if (e) c.push("</tr>");
                    c.push("<tr>");
                    e = true;
                }
                c.push('<td class="legendColorBox"><div style="border:1px solid ' + i.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + m.color + ';overflow:hidden"></div></div></td>' + '<td class="legendLabel">' + m.label + "</td>");
            }
            if (e) c.push("</tr>");
            if (c.length == 0) return;
            var n = '<table style="font-size:smaller;color:' + i.grid.color + '">' + c.join("") + "</table>";
            if (i.legend.container != null) a(i.legend.container).html(n); else {
                var o = "", p = i.legend.position, r = i.legend.margin;
                if (r[0] == null) r = [ r, r ];
                if (p.charAt(0) == "n") o += "top:" + (r[1] + q.top) + "px;"; else if (p.charAt(0) == "s") o += "bottom:" + (r[1] + q.bottom) + "px;";
                if (p.charAt(1) == "e") o += "right:" + (r[0] + q.right) + "px;"; else if (p.charAt(1) == "w") o += "left:" + (r[0] + q.left) + "px;";
                var s = a('<div class="legend">' + n.replace('style="', 'style="position:absolute;' + o + ";") + "</div>").appendTo(b);
                if (i.legend.backgroundOpacity != 0) {
                    var t = i.legend.backgroundColor;
                    if (t == null) {
                        t = i.grid.backgroundColor;
                        if (t && typeof t == "string") t = a.color.parse(t); else t = a.color.extract(s, "background-color");
                        t.a = 1;
                        t = t.toString();
                    }
                    var u = s.children();
                    a('<div style="position:absolute;width:' + u.width() + "px;height:" + u.height() + "px;" + o + "background-color:" + t + ';"> </div>').prependTo(s).css("opacity", i.legend.backgroundOpacity);
                }
            }
        }
        var eb = [], fb = null;
        function gb(a, b, c) {
            var d = i.grid.mouseActiveRadius, e = d * d + 1, f = null, g = false, j, k, l;
            for (j = h.length - 1; j >= 0; --j) {
                if (!c(h[j])) continue;
                var m = h[j], n = m.xaxis, o = m.yaxis, p = m.datapoints.points, q = n.c2p(a), r = o.c2p(b), s = d / n.scale, t = d / o.scale;
                l = m.datapoints.pointsize;
                if (n.options.inverseTransform) s = Number.MAX_VALUE;
                if (o.options.inverseTransform) t = Number.MAX_VALUE;
                if (m.lines.show || m.points.show) {
                    for (k = 0; k < p.length; k += l) {
                        var u = p[k], v = p[k + 1];
                        if (u == null) continue;
                        if (u - q > s || u - q < -s || v - r > t || v - r < -t) continue;
                        var w = Math.abs(n.p2c(u) - a), x = Math.abs(o.p2c(v) - b), y = w * w + x * x;
                        if (y < e) {
                            e = y;
                            f = [ j, k / l ];
                        }
                    }
                }
                if (m.bars.show && !f) {
                    var z = m.bars.align == "left" ? 0 : -m.bars.barWidth / 2, A = z + m.bars.barWidth;
                    for (k = 0; k < p.length; k += l) {
                        var u = p[k], v = p[k + 1], B = p[k + 2];
                        if (u == null) continue;
                        if (h[j].bars.horizontal ? q <= Math.max(B, u) && q >= Math.min(B, u) && r >= v + z && r <= v + A : q >= u + z && q <= u + A && r >= Math.min(B, v) && r <= Math.max(B, v)) f = [ j, k / l ];
                    }
                }
            }
            if (f) {
                j = f[0];
                k = f[1];
                l = h[j].datapoints.pointsize;
                return {
                    datapoint: h[j].datapoints.points.slice(k * l, (k + 1) * l),
                    dataIndex: k,
                    series: h[j],
                    seriesIndex: j
                };
            }
            return null;
        }
        function hb(a) {
            if (i.grid.hoverable) kb("plothover", a, function(a) {
                return a["hoverable"] != false;
            });
        }
        function ib(a) {
            if (i.grid.hoverable) kb("plothover", a, function(a) {
                return false;
            });
        }
        function jb(a) {
            kb("plotclick", a, function(a) {
                return a["clickable"] != false;
            });
        }
        function kb(a, c, d) {
            var e = l.offset(), f = c.pageX - e.left - q.left, g = c.pageY - e.top - q.top, h = C({
                left: f,
                top: g
            });
            h.pageX = c.pageX;
            h.pageY = c.pageY;
            var j = gb(f, g, d);
            if (j) {
                j.pageX = parseInt(j.series.xaxis.p2c(j.datapoint[0]) + e.left + q.left, 10);
                j.pageY = parseInt(j.series.yaxis.p2c(j.datapoint[1]) + e.top + q.top, 10);
            }
            if (i.grid.autoHighlight) {
                for (var k = 0; k < eb.length; ++k) {
                    var m = eb[k];
                    if (m.auto == a && !(j && m.series == j.series && m.point[0] == j.datapoint[0] && m.point[1] == j.datapoint[1])) ob(m.series, m.point);
                }
                if (j) nb(j.series, j.datapoint, a);
            }
            b.trigger(a, [ h, j ]);
        }
        function lb() {
            var a = i.interaction.redrawOverlayInterval;
            if (a == -1) {
                mb();
                return;
            }
            if (!fb) fb = setTimeout(mb, a);
        }
        function mb() {
            fb = null;
            n.save();
            k.clear();
            n.translate(q.left, q.top);
            var a, b;
            for (a = 0; a < eb.length; ++a) {
                b = eb[a];
                if (b.series.bars.show) rb(b.series, b.point); else qb(b.series, b.point);
            }
            n.restore();
            v(t.drawOverlay, [ n ]);
        }
        function nb(a, b, c) {
            if (typeof a == "number") a = h[a];
            if (typeof b == "number") {
                var d = a.datapoints.pointsize;
                b = a.datapoints.points.slice(d * b, d * (b + 1));
            }
            var e = pb(a, b);
            if (e == -1) {
                eb.push({
                    series: a,
                    point: b,
                    auto: c
                });
                lb();
            } else if (!c) eb[e].auto = false;
        }
        function ob(a, b) {
            if (a == null && b == null) {
                eb = [];
                lb();
                return;
            }
            if (typeof a == "number") a = h[a];
            if (typeof b == "number") {
                var c = a.datapoints.pointsize;
                b = a.datapoints.points.slice(c * b, c * (b + 1));
            }
            var d = pb(a, b);
            if (d != -1) {
                eb.splice(d, 1);
                lb();
            }
        }
        function pb(a, b) {
            for (var c = 0; c < eb.length; ++c) {
                var d = eb[c];
                if (d.series == a && d.point[0] == b[0] && d.point[1] == b[1]) return c;
            }
            return -1;
        }
        function qb(b, c) {
            var d = c[0], e = c[1], f = b.xaxis, g = b.yaxis, h = typeof b.highlightColor === "string" ? b.highlightColor : a.color.parse(b.color).scale("a", .5).toString();
            if (d < f.min || d > f.max || e < g.min || e > g.max) return;
            var i = b.points.radius + b.points.lineWidth / 2;
            n.lineWidth = i;
            n.strokeStyle = h;
            var j = 1.5 * i;
            d = f.p2c(d);
            e = g.p2c(e);
            n.beginPath();
            if (b.points.symbol == "circle") n.arc(d, e, j, 0, 2 * Math.PI, false); else b.points.symbol(n, d, e, j, false);
            n.closePath();
            n.stroke();
        }
        function rb(b, c) {
            var d = typeof b.highlightColor === "string" ? b.highlightColor : a.color.parse(b.color).scale("a", .5).toString(), e = d, f = b.bars.align == "left" ? 0 : -b.bars.barWidth / 2;
            n.lineWidth = b.bars.lineWidth;
            n.strokeStyle = d;
            ab(c[0], c[1], c[2] || 0, f, f + b.bars.barWidth, 0, function() {
                return e;
            }, b.xaxis, b.yaxis, n, b.bars.horizontal, b.bars.lineWidth);
        }
        function sb(b, c, d, e) {
            if (typeof b == "string") return b; else {
                var f = m.createLinearGradient(0, d, 0, c);
                for (var g = 0, h = b.colors.length; g < h; ++g) {
                    var i = b.colors[g];
                    if (typeof i != "string") {
                        var j = a.color.parse(e);
                        if (i.brightness != null) j = j.scale("rgb", i.brightness);
                        if (i.opacity != null) j.a *= i.opacity;
                        i = j.toString();
                    }
                    f.addColorStop(g / (h - 1), i);
                }
                return f;
            }
        }
    }
    a.plot = function(b, c, e) {
        var f = new d(a(b), c, e, a.plot.plugins);
        return f;
    };
    a.plot.version = "0.8.0";
    a.plot.plugins = [];
    a.fn.plot = function(b, c) {
        return this.each(function() {
            a.plot(this, b, c);
        });
    };
    function e(a, b) {
        return b * Math.floor(a / b);
    }
})(jQuery);

(function(a) {
    function b(b) {
        var c = {
            first: {
                x: -1,
                y: -1
            },
            second: {
                x: -1,
                y: -1
            },
            show: false,
            active: false
        };
        var d = {};
        var e = null;
        function f(a) {
            if (c.active) {
                m(a);
                b.getPlaceholder().trigger("plotselecting", [ i() ]);
            }
        }
        function g(b) {
            if (b.which != 1) return;
            document.body.focus();
            if (document.onselectstart !== undefined && d.onselectstart == null) {
                d.onselectstart = document.onselectstart;
                document.onselectstart = function() {
                    return false;
                };
            }
            if (document.ondrag !== undefined && d.ondrag == null) {
                d.ondrag = document.ondrag;
                document.ondrag = function() {
                    return false;
                };
            }
            l(c.first, b);
            c.active = true;
            e = function(a) {
                h(a);
            };
            a(document).one("mouseup", e);
        }
        function h(a) {
            e = null;
            if (document.onselectstart !== undefined) document.onselectstart = d.onselectstart;
            if (document.ondrag !== undefined) document.ondrag = d.ondrag;
            c.active = false;
            m(a);
            if (q()) j(); else {
                b.getPlaceholder().trigger("plotunselected", []);
                b.getPlaceholder().trigger("plotselecting", [ null ]);
            }
            return false;
        }
        function i() {
            if (!q()) return null;
            if (!c.show) return null;
            var d = {}, e = c.first, f = c.second;
            a.each(b.getAxes(), function(a, b) {
                if (b.used) {
                    var c = b.c2p(e[b.direction]), g = b.c2p(f[b.direction]);
                    d[a] = {
                        from: Math.min(c, g),
                        to: Math.max(c, g)
                    };
                }
            });
            return d;
        }
        function j() {
            var a = i();
            b.getPlaceholder().trigger("plotselected", [ a ]);
            if (a.xaxis && a.yaxis) b.getPlaceholder().trigger("selected", [ {
                x1: a.xaxis.from,
                y1: a.yaxis.from,
                x2: a.xaxis.to,
                y2: a.yaxis.to
            } ]);
        }
        function k(a, b, c) {
            return b < a ? a : b > c ? c : b;
        }
        function l(a, d) {
            var e = b.getOptions();
            var f = b.getPlaceholder().offset();
            var g = b.getPlotOffset();
            a.x = k(0, d.pageX - f.left - g.left, b.width());
            a.y = k(0, d.pageY - f.top - g.top, b.height());
            if (e.selection.mode == "y") a.x = a == c.first ? 0 : b.width();
            if (e.selection.mode == "x") a.y = a == c.first ? 0 : b.height();
        }
        function m(a) {
            if (a.pageX == null) return;
            l(c.second, a);
            if (q()) {
                c.show = true;
                b.triggerRedrawOverlay();
            } else n(true);
        }
        function n(a) {
            if (c.show) {
                c.show = false;
                b.triggerRedrawOverlay();
                if (!a) b.getPlaceholder().trigger("plotunselected", []);
            }
        }
        function o(a, c) {
            var d, e, f, g, h = b.getAxes();
            for (var i in h) {
                d = h[i];
                if (d.direction == c) {
                    g = c + d.n + "axis";
                    if (!a[g] && d.n == 1) g = c + "axis";
                    if (a[g]) {
                        e = a[g].from;
                        f = a[g].to;
                        break;
                    }
                }
            }
            if (!a[g]) {
                d = c == "x" ? b.getXAxes()[0] : b.getYAxes()[0];
                e = a[c + "1"];
                f = a[c + "2"];
            }
            if (e != null && f != null && e > f) {
                var j = e;
                e = f;
                f = j;
            }
            return {
                from: e,
                to: f,
                axis: d
            };
        }
        function p(a, d) {
            var e, f, g = b.getOptions();
            if (g.selection.mode == "y") {
                c.first.x = 0;
                c.second.x = b.width();
            } else {
                f = o(a, "x");
                c.first.x = f.axis.p2c(f.from);
                c.second.x = f.axis.p2c(f.to);
            }
            if (g.selection.mode == "x") {
                c.first.y = 0;
                c.second.y = b.height();
            } else {
                f = o(a, "y");
                c.first.y = f.axis.p2c(f.from);
                c.second.y = f.axis.p2c(f.to);
            }
            c.show = true;
            b.triggerRedrawOverlay();
            if (!d && q()) j();
        }
        function q() {
            var a = b.getOptions().selection.minSize;
            return Math.abs(c.second.x - c.first.x) >= a && Math.abs(c.second.y - c.first.y) >= a;
        }
        b.clearSelection = n;
        b.setSelection = p;
        b.getSelection = i;
        b.hooks.bindEvents.push(function(a, b) {
            var c = a.getOptions();
            if (c.selection.mode != null) {
                b.mousemove(f);
                b.mousedown(g);
            }
        });
        b.hooks.drawOverlay.push(function(b, d) {
            if (c.show && q()) {
                var e = b.getPlotOffset();
                var f = b.getOptions();
                d.save();
                d.translate(e.left, e.top);
                var g = a.color.parse(f.selection.color);
                d.strokeStyle = g.scale("a", .8).toString();
                d.lineWidth = 1;
                d.lineJoin = f.selection.shape;
                d.fillStyle = g.scale("a", .4).toString();
                var h = Math.min(c.first.x, c.second.x) + .5, i = Math.min(c.first.y, c.second.y) + .5, j = Math.abs(c.second.x - c.first.x) - 1, k = Math.abs(c.second.y - c.first.y) - 1;
                d.fillRect(h, i, j, k);
                d.strokeRect(h, i, j, k);
                d.restore();
            }
        });
        b.hooks.shutdown.push(function(b, c) {
            c.unbind("mousemove", f);
            c.unbind("mousedown", g);
            if (e) a(document).unbind("mouseup", e);
        });
    }
    a.plot.plugins.push({
        init: b,
        options: {
            selection: {
                mode: null,
                color: "#e8cfac",
                shape: "round",
                minSize: 5
            }
        },
        name: "selection",
        version: "1.1"
    });
})(jQuery);

(function(a) {
    var b = 10;
    var c = .95;
    function d(d) {
        var f = null, g = null, h = null, i = null, j = null, k = false, l = null;
        var m = [];
        d.hooks.processOptions.push(function(a, b) {
            if (b.series.pie.show) {
                b.grid.show = false;
                if (b.series.pie.label.show == "auto") {
                    if (b.legend.show) {
                        b.series.pie.label.show = false;
                    } else {
                        b.series.pie.label.show = true;
                    }
                }
                if (b.series.pie.radius == "auto") {
                    if (b.series.pie.label.show) {
                        b.series.pie.radius = 3 / 4;
                    } else {
                        b.series.pie.radius = 1;
                    }
                }
                if (b.series.pie.tilt > 1) {
                    b.series.pie.tilt = 1;
                } else if (b.series.pie.tilt < 0) {
                    b.series.pie.tilt = 0;
                }
            }
        });
        d.hooks.bindEvents.push(function(a, b) {
            var c = a.getOptions();
            if (c.series.pie.show) {
                if (c.grid.hoverable) {
                    b.unbind("mousemove").mousemove(t);
                }
                if (c.grid.clickable) {
                    b.unbind("click").click(u);
                }
            }
        });
        d.hooks.processDatapoints.push(function(a, b, c, d) {
            var e = a.getOptions();
            if (e.series.pie.show) {
                n(a, b, c, d);
            }
        });
        d.hooks.drawOverlay.push(function(a, b) {
            var c = a.getOptions();
            if (c.series.pie.show) {
                z(a, b);
            }
        });
        d.hooks.draw.push(function(a, b) {
            var c = a.getOptions();
            if (c.series.pie.show) {
                p(a, b);
            }
        });
        function n(b, c, d) {
            if (!k) {
                k = true;
                f = b.getCanvas();
                g = a(f).parent();
                e = b.getOptions();
                b.setData(o(b.getData()));
            }
        }
        function o(b) {
            var c = 0, d = 0, f = 0, g = e.series.pie.combine.color, h = [];
            for (var i = 0; i < b.length; ++i) {
                var j = b[i].data;
                if (a.isArray(j)) {
                    if (a.isNumeric(j[1])) {
                        j[1] = +j[1];
                    } else {
                        j[1] = 0;
                    }
                } else if (a.isNumeric(j)) {
                    j = [ 1, +j ];
                } else {
                    j = [ 1, 0 ];
                }
                b[i].data = [ j ];
            }
            for (var i = 0; i < b.length; ++i) {
                c += b[i].data[0][1];
            }
            for (var i = 0; i < b.length; ++i) {
                var j = b[i].data[0][1];
                if (j / c <= e.series.pie.combine.threshold) {
                    d += j;
                    f++;
                    if (!g) {
                        g = b[i].color;
                    }
                }
            }
            for (var i = 0; i < b.length; ++i) {
                var j = b[i].data[0][1];
                if (f < 2 || j / c > e.series.pie.combine.threshold) {
                    h.push({
                        data: [ [ 1, j ] ],
                        color: b[i].color,
                        label: b[i].label,
                        angle: j * Math.PI * 2 / c,
                        percent: j / (c / 100)
                    });
                }
            }
            if (f > 1) {
                h.push({
                    data: [ [ 1, d ] ],
                    color: g,
                    label: e.series.pie.combine.label,
                    angle: d * Math.PI * 2 / c,
                    percent: d / (c / 100)
                });
            }
            return h;
        }
        function p(d, f) {
            if (!g) {
                return;
            }
            var m = d.getPlaceholder().width(), n = d.getPlaceholder().height(), o = g.children().filter(".legend").children().width() || 0;
            l = f;
            k = false;
            h = Math.min(m, n / e.series.pie.tilt) / 2;
            j = n / 2 + e.series.pie.offset.top;
            i = m / 2;
            if (e.series.pie.offset.left == "auto") {
                if (e.legend.position.match("w")) {
                    i += o / 2;
                } else {
                    i -= o / 2;
                }
            } else {
                i += e.series.pie.offset.left;
            }
            if (i < h) {
                i = h;
            } else if (i > m - h) {
                i = m - h;
            }
            var p = d.getData(), r = 0;
            do {
                if (r > 0) {
                    h *= c;
                }
                r += 1;
                s();
                if (e.series.pie.tilt <= .8) {
                    t();
                }
            } while (!u() && r < b);
            if (r >= b) {
                s();
                g.prepend("<div class='error'>Could not draw pie with labels contained inside canvas</div>");
            }
            if (d.setSeries && d.insertLegend) {
                d.setSeries(p);
                d.insertLegend();
            }
            function s() {
                l.clearRect(0, 0, m, n);
                g.children().filter(".pieLabel, .pieLabelBackground").remove();
            }
            function t() {
                var a = e.series.pie.shadow.left;
                var b = e.series.pie.shadow.top;
                var c = 10;
                var d = e.series.pie.shadow.alpha;
                var f = e.series.pie.radius > 1 ? e.series.pie.radius : h * e.series.pie.radius;
                if (f >= m / 2 - a || f * e.series.pie.tilt >= n / 2 - b || f <= c) {
                    return;
                }
                l.save();
                l.translate(a, b);
                l.globalAlpha = d;
                l.fillStyle = "#000";
                l.translate(i, j);
                l.scale(1, e.series.pie.tilt);
                for (var g = 1; g <= c; g++) {
                    l.beginPath();
                    l.arc(0, 0, f, 0, Math.PI * 2, false);
                    l.fill();
                    f -= g;
                }
                l.restore();
            }
            function u() {
                var b = Math.PI * e.series.pie.startAngle;
                var c = e.series.pie.radius > 1 ? e.series.pie.radius : h * e.series.pie.radius;
                l.save();
                l.translate(i, j);
                l.scale(1, e.series.pie.tilt);
                l.save();
                var d = b;
                for (var f = 0; f < p.length; ++f) {
                    p[f].startAngle = d;
                    k(p[f].angle, p[f].color, true);
                }
                l.restore();
                if (e.series.pie.stroke.width > 0) {
                    l.save();
                    l.lineWidth = e.series.pie.stroke.width;
                    d = b;
                    for (var f = 0; f < p.length; ++f) {
                        k(p[f].angle, e.series.pie.stroke.color, false);
                    }
                    l.restore();
                }
                q(l);
                l.restore();
                if (e.series.pie.label.show) {
                    return o();
                } else return true;
                function k(a, b, e) {
                    if (a <= 0 || isNaN(a)) {
                        return;
                    }
                    if (e) {
                        l.fillStyle = b;
                    } else {
                        l.strokeStyle = b;
                        l.lineJoin = "round";
                    }
                    l.beginPath();
                    if (Math.abs(a - Math.PI * 2) > 1e-9) {
                        l.moveTo(0, 0);
                    }
                    l.arc(0, 0, c, d, d + a / 2, false);
                    l.arc(0, 0, c, d + a / 2, d + a, false);
                    l.closePath();
                    d += a;
                    if (e) {
                        l.fill();
                    } else {
                        l.stroke();
                    }
                }
                function o() {
                    var c = b;
                    var d = e.series.pie.label.radius > 1 ? e.series.pie.label.radius : h * e.series.pie.label.radius;
                    for (var f = 0; f < p.length; ++f) {
                        if (p[f].percent >= e.series.pie.label.threshold * 100) {
                            if (!k(p[f], c, f)) {
                                return false;
                            }
                        }
                        c += p[f].angle;
                    }
                    return true;
                    function k(b, c, f) {
                        if (b.data[0][1] == 0) {
                            return true;
                        }
                        var h = e.legend.labelFormatter, k, l = e.series.pie.label.formatter;
                        if (h) {
                            k = h(b.label, b);
                        } else {
                            k = b.label;
                        }
                        if (l) {
                            k = l(k, b);
                        }
                        var o = (c + b.angle + c) / 2;
                        var p = i + Math.round(Math.cos(o) * d);
                        var q = j + Math.round(Math.sin(o) * d) * e.series.pie.tilt;
                        var r = "<span class='pieLabel' id='pieLabel" + f + "' style='position:absolute;top:" + q + "px;left:" + p + "px;'>" + k + "</span>";
                        g.append(r);
                        var s = g.children("#pieLabel" + f);
                        var t = q - s.height() / 2;
                        var u = p - s.width() / 2;
                        s.css("top", t);
                        s.css("left", u);
                        if (0 - t > 0 || 0 - u > 0 || n - (t + s.height()) < 0 || m - (u + s.width()) < 0) {
                            return false;
                        }
                        if (e.series.pie.label.background.opacity != 0) {
                            var v = e.series.pie.label.background.color;
                            if (v == null) {
                                v = b.color;
                            }
                            var w = "top:" + t + "px;left:" + u + "px;";
                            a("<div class='pieLabelBackground' style='position:absolute;width:" + s.width() + "px;height:" + s.height() + "px;" + w + "background-color:" + v + ";'></div>").css("opacity", e.series.pie.label.background.opacity).insertBefore(s);
                        }
                        return true;
                    }
                }
            }
        }
        function q(a) {
            if (e.series.pie.innerRadius > 0) {
                a.save();
                var b = e.series.pie.innerRadius > 1 ? e.series.pie.innerRadius : h * e.series.pie.innerRadius;
                a.globalCompositeOperation = "destination-out";
                a.beginPath();
                a.fillStyle = e.series.pie.stroke.color;
                a.arc(0, 0, b, 0, Math.PI * 2, false);
                a.fill();
                a.closePath();
                a.restore();
                a.save();
                a.beginPath();
                a.strokeStyle = e.series.pie.stroke.color;
                a.arc(0, 0, b, 0, Math.PI * 2, false);
                a.stroke();
                a.closePath();
                a.restore();
            }
        }
        function r(a, b) {
            for (var c = false, d = -1, e = a.length, f = e - 1; ++d < e; f = d) (a[d][1] <= b[1] && b[1] < a[f][1] || a[f][1] <= b[1] && b[1] < a[d][1]) && b[0] < (a[f][0] - a[d][0]) * (b[1] - a[d][1]) / (a[f][1] - a[d][1]) + a[d][0] && (c = !c);
            return c;
        }
        function s(a, b) {
            var c = d.getData(), e = d.getOptions(), f = e.series.pie.radius > 1 ? e.series.pie.radius : h * e.series.pie.radius, g, k;
            for (var m = 0; m < c.length; ++m) {
                var n = c[m];
                if (n.pie.show) {
                    l.save();
                    l.beginPath();
                    l.moveTo(0, 0);
                    l.arc(0, 0, f, n.startAngle, n.startAngle + n.angle / 2, false);
                    l.arc(0, 0, f, n.startAngle + n.angle / 2, n.startAngle + n.angle, false);
                    l.closePath();
                    g = a - i;
                    k = b - j;
                    if (l.isPointInPath) {
                        if (l.isPointInPath(a - i, b - j)) {
                            l.restore();
                            return {
                                datapoint: [ n.percent, n.data ],
                                dataIndex: 0,
                                series: n,
                                seriesIndex: m
                            };
                        }
                    } else {
                        var o = f * Math.cos(n.startAngle), p = f * Math.sin(n.startAngle), q = f * Math.cos(n.startAngle + n.angle / 4), s = f * Math.sin(n.startAngle + n.angle / 4), t = f * Math.cos(n.startAngle + n.angle / 2), u = f * Math.sin(n.startAngle + n.angle / 2), v = f * Math.cos(n.startAngle + n.angle / 1.5), w = f * Math.sin(n.startAngle + n.angle / 1.5), x = f * Math.cos(n.startAngle + n.angle), y = f * Math.sin(n.startAngle + n.angle), z = [ [ 0, 0 ], [ o, p ], [ q, s ], [ t, u ], [ v, w ], [ x, y ] ], A = [ g, k ];
                        if (r(z, A)) {
                            l.restore();
                            return {
                                datapoint: [ n.percent, n.data ],
                                dataIndex: 0,
                                series: n,
                                seriesIndex: m
                            };
                        }
                    }
                    l.restore();
                }
            }
            return null;
        }
        function t(a) {
            v("plothover", a);
        }
        function u(a) {
            v("plotclick", a);
        }
        function v(a, b) {
            var c = d.offset();
            var f = parseInt(b.pageX - c.left);
            var h = parseInt(b.pageY - c.top);
            var i = s(f, h);
            if (e.grid.autoHighlight) {
                for (var j = 0; j < m.length; ++j) {
                    var k = m[j];
                    if (k.auto == a && !(i && k.series == i.series)) {
                        x(k.series);
                    }
                }
            }
            if (i) {
                w(i.series, a);
            }
            var l = {
                pageX: b.pageX,
                pageY: b.pageY
            };
            g.trigger(a, [ l, i ]);
        }
        function w(a, b) {
            var c = y(a);
            if (c == -1) {
                m.push({
                    series: a,
                    auto: b
                });
                d.triggerRedrawOverlay();
            } else if (!b) {
                m[c].auto = false;
            }
        }
        function x(a) {
            if (a == null) {
                m = [];
                d.triggerRedrawOverlay();
            }
            var b = y(a);
            if (b != -1) {
                m.splice(b, 1);
                d.triggerRedrawOverlay();
            }
        }
        function y(a) {
            for (var b = 0; b < m.length; ++b) {
                var c = m[b];
                if (c.series == a) return b;
            }
            return -1;
        }
        function z(a, b) {
            var c = a.getOptions();
            var d = c.series.pie.radius > 1 ? c.series.pie.radius : h * c.series.pie.radius;
            b.save();
            b.translate(i, j);
            b.scale(1, c.series.pie.tilt);
            for (var e = 0; e < m.length; ++e) {
                f(m[e].series);
            }
            q(b);
            b.restore();
            function f(a) {
                if (a.angle <= 0 || isNaN(a.angle)) {
                    return;
                }
                b.fillStyle = "rgba(255, 255, 255, " + c.series.pie.highlight.opacity + ")";
                b.beginPath();
                if (Math.abs(a.angle - Math.PI * 2) > 1e-9) {
                    b.moveTo(0, 0);
                }
                b.arc(0, 0, d, a.startAngle, a.startAngle + a.angle / 2, false);
                b.arc(0, 0, d, a.startAngle + a.angle / 2, a.startAngle + a.angle, false);
                b.closePath();
                b.fill();
            }
        }
    }
    var e = {
        series: {
            pie: {
                show: false,
                radius: "auto",
                innerRadius: 0,
                startAngle: 3 / 2,
                tilt: 1,
                shadow: {
                    left: 5,
                    top: 15,
                    alpha: .02
                },
                offset: {
                    top: 0,
                    left: "auto"
                },
                stroke: {
                    color: "#fff",
                    width: 1
                },
                label: {
                    show: "auto",
                    formatter: function(a, b) {
                        return "<div style='font-size:x-small;text-align:center;padding:2px;color:" + b.color + ";'>" + a + "<br/>" + Math.round(b.percent) + "%</div>";
                    },
                    radius: 1,
                    background: {
                        color: null,
                        opacity: 0
                    },
                    threshold: 0
                },
                combine: {
                    threshold: -1,
                    color: null,
                    label: "Other"
                },
                highlight: {
                    opacity: .5
                }
            }
        }
    };
    a.plot.plugins.push({
        init: d,
        options: e,
        name: "pie",
        version: "1.1"
    });
})(jQuery);

(function(a) {
    var b = {
        xaxis: {
            categories: null
        },
        yaxis: {
            categories: null
        }
    };
    function c(a, b, c, d) {
        var e = b.xaxis.options.mode == "categories", f = b.yaxis.options.mode == "categories";
        if (!(e || f)) return;
        var g = d.format;
        if (!g) {
            var h = b;
            g = [];
            g.push({
                x: true,
                number: true,
                required: true
            });
            g.push({
                y: true,
                number: true,
                required: true
            });
            if (h.bars.show || h.lines.show && h.lines.fill) {
                var i = !!(h.bars.show && h.bars.zero || h.lines.show && h.lines.zero);
                g.push({
                    y: true,
                    number: true,
                    required: false,
                    defaultValue: 0,
                    autoscale: i
                });
                if (h.bars.horizontal) {
                    delete g[g.length - 1].y;
                    g[g.length - 1].x = true;
                }
            }
            d.format = g;
        }
        for (var j = 0; j < g.length; ++j) {
            if (g[j].x && e) g[j].number = false;
            if (g[j].y && f) g[j].number = false;
        }
    }
    function d(a) {
        var b = -1;
        for (var c in a) if (a[c] > b) b = a[c];
        return b + 1;
    }
    function e(a) {
        var b = [];
        for (var c in a.categories) {
            var d = a.categories[c];
            if (d >= a.min && d <= a.max) b.push([ d, c ]);
        }
        b.sort(function(a, b) {
            return a[0] - b[0];
        });
        return b;
    }
    function f(b, c, d) {
        if (b[c].options.mode != "categories") return;
        if (!b[c].categories) {
            var f = {}, h = b[c].options.categories || {};
            if (a.isArray(h)) {
                for (var i = 0; i < h.length; ++i) f[h[i]] = i;
            } else {
                for (var j in h) f[j] = h[j];
            }
            b[c].categories = f;
        }
        if (!b[c].options.ticks) b[c].options.ticks = e;
        g(d, c, b[c].categories);
    }
    function g(a, b, c) {
        var e = a.points, f = a.pointsize, g = a.format, h = b.charAt(0), i = d(c);
        for (var j = 0; j < e.length; j += f) {
            if (e[j] == null) continue;
            for (var k = 0; k < f; ++k) {
                var l = e[j + k];
                if (l == null || !g[k][h]) continue;
                if (!(l in c)) {
                    c[l] = i;
                    ++i;
                }
                e[j + k] = c[l];
            }
        }
    }
    function h(a, b, c) {
        f(b, "xaxis", c);
        f(b, "yaxis", c);
    }
    function i(a) {
        a.hooks.processRawData.push(c);
        a.hooks.processDatapoints.push(h);
    }
    a.plot.plugins.push({
        init: i,
        options: b,
        name: "categories",
        version: "1.0"
    });
})(jQuery);

(function(a) {
    function b(a, b, c) {
        var d = {
            square: function(a, b, c, d, e) {
                var f = d * Math.sqrt(Math.PI) / 2;
                a.rect(b - f, c - f, f + f, f + f);
            },
            diamond: function(a, b, c, d, e) {
                var f = d * Math.sqrt(Math.PI / 2);
                a.moveTo(b - f, c);
                a.lineTo(b, c - f);
                a.lineTo(b + f, c);
                a.lineTo(b, c + f);
                a.lineTo(b - f, c);
            },
            triangle: function(a, b, c, d, e) {
                var f = d * Math.sqrt(2 * Math.PI / Math.sin(Math.PI / 3));
                var g = f * Math.sin(Math.PI / 3);
                a.moveTo(b - f / 2, c + g / 2);
                a.lineTo(b + f / 2, c + g / 2);
                if (!e) {
                    a.lineTo(b, c - g / 2);
                    a.lineTo(b - f / 2, c + g / 2);
                }
            },
            cross: function(a, b, c, d, e) {
                var f = d * Math.sqrt(Math.PI) / 2;
                a.moveTo(b - f, c - f);
                a.lineTo(b + f, c + f);
                a.moveTo(b - f, c + f);
                a.lineTo(b + f, c - f);
            }
        };
        var e = b.points.symbol;
        if (d[e]) b.points.symbol = d[e];
    }
    function c(a) {
        a.hooks.processDatapoints.push(b);
    }
    a.plot.plugins.push({
        init: c,
        name: "symbols",
        version: "1.0"
    });
})(jQuery);

(function(a) {
    var b = {
        tooltip: false,
        tooltipOpts: {
            content: "%s | X: %x | Y: %y",
            xDateFormat: null,
            yDateFormat: null,
            shifts: {
                x: 10,
                y: 20
            },
            defaultTheme: true,
            onHover: function(a, b) {}
        }
    };
    var c = function(a) {
        this.tipPosition = {
            x: 0,
            y: 0
        };
        this.init(a);
    };
    c.prototype.init = function(b) {
        var c = this;
        b.hooks.bindEvents.push(function(b, f) {
            c.plotOptions = b.getOptions();
            if (c.plotOptions.tooltip === false || typeof c.plotOptions.tooltip === "undefined") return;
            c.tooltipOptions = c.plotOptions.tooltipOpts;
            var g = c.getDomElement();
            a(b.getPlaceholder()).bind("plothover", e);
            a(f).bind("mousemove", d);
        });
        b.hooks.shutdown.push(function(b, c) {
            a(b.getPlaceholder()).unbind("plothover", e);
            a(c).unbind("mousemove", d);
        });
        function d(a) {
            var b = {};
            b.x = a.pageX;
            b.y = a.pageY;
            c.updateTooltipPosition(b);
        }
        function e(a, b, d) {
            var e = c.getDomElement();
            if (d) {
                var f;
                f = c.stringFormat(c.tooltipOptions.content, d);
                e.html(f);
                c.updateTooltipPosition({
                    x: b.pageX,
                    y: b.pageY
                });
                e.css({
                    left: c.tipPosition.x + c.tooltipOptions.shifts.x,
                    top: c.tipPosition.y + c.tooltipOptions.shifts.y
                }).show();
                if (typeof c.tooltipOptions.onHover === "function") {
                    c.tooltipOptions.onHover(d, e);
                }
            } else {
                e.hide().html("");
            }
        }
    };
    c.prototype.getDomElement = function() {
        var b;
        if (a("#flotTip").length > 0) {
            b = a("#flotTip");
        } else {
            b = a("<div />").attr("id", "flotTip");
            b.appendTo("body").hide().css({
                position: "absolute"
            });
            if (this.tooltipOptions.defaultTheme) {
                b.css({
                    background: "#fff",
                    "z-index": "100",
                    padding: "0.4em 0.6em",
                    "border-radius": "0.5em",
                    "font-size": "0.8em",
                    border: "1px solid #111",
                    display: "none",
                    "white-space": "nowrap"
                });
            }
        }
        return b;
    };
    c.prototype.updateTooltipPosition = function(b) {
        var c = a("#flotTip").outerWidth() + this.tooltipOptions.shifts.x;
        var d = a("#flotTip").outerHeight() + this.tooltipOptions.shifts.y;
        if (b.x - a(window).scrollLeft() > a(window).innerWidth() - c) {
            b.x -= c;
        }
        if (b.y - a(window).scrollTop() > a(window).innerHeight() - d) {
            b.y -= d;
        }
        this.tipPosition.x = b.x;
        this.tipPosition.y = b.y;
    };
    c.prototype.stringFormat = function(a, b) {
        var c = /%p\.{0,1}(\d{0,})/;
        var d = /%s/;
        var e = /%x\.{0,1}(?:\d{0,})/;
        var f = /%y\.{0,1}(?:\d{0,})/;
        if (typeof a === "function") {
            a = a(b.series.label, b.series.data[b.dataIndex][0], b.series.data[b.dataIndex][1], b);
        }
        if (typeof b.series.percent !== "undefined") {
            a = this.adjustValPrecision(c, a, b.series.percent);
        }
        if (typeof b.series.label !== "undefined") {
            a = a.replace(d, b.series.label);
        }
        if (this.isTimeMode("xaxis", b) && this.isXDateFormat(b)) {
            a = a.replace(e, this.timestampToDate(b.series.data[b.dataIndex][0], this.tooltipOptions.xDateFormat));
        }
        if (this.isTimeMode("yaxis", b) && this.isYDateFormat(b)) {
            a = a.replace(f, this.timestampToDate(b.series.data[b.dataIndex][1], this.tooltipOptions.yDateFormat));
        }
        if (typeof b.series.data[b.dataIndex][0] === "number") {
            a = this.adjustValPrecision(e, a, b.series.data[b.dataIndex][0]);
        }
        if (typeof b.series.data[b.dataIndex][1] === "number") {
            a = this.adjustValPrecision(f, a, b.series.data[b.dataIndex][1]);
        }
        if (typeof b.series.xaxis.tickFormatter !== "undefined") {
            a = a.replace(e, b.series.xaxis.tickFormatter(b.series.data[b.dataIndex][0], b.series.xaxis));
        }
        if (typeof b.series.yaxis.tickFormatter !== "undefined") {
            a = a.replace(f, b.series.yaxis.tickFormatter(b.series.data[b.dataIndex][1], b.series.yaxis));
        }
        return a;
    };
    c.prototype.isTimeMode = function(a, b) {
        return typeof b.series[a].options.mode !== "undefined" && b.series[a].options.mode === "time";
    };
    c.prototype.isXDateFormat = function(a) {
        return typeof this.tooltipOptions.xDateFormat !== "undefined" && this.tooltipOptions.xDateFormat !== null;
    };
    c.prototype.isYDateFormat = function(a) {
        return typeof this.tooltipOptions.yDateFormat !== "undefined" && this.tooltipOptions.yDateFormat !== null;
    };
    c.prototype.timestampToDate = function(b, c) {
        var d = new Date(b);
        return a.plot.formatDate(d, c);
    };
    c.prototype.adjustValPrecision = function(a, b, c) {
        var d;
        var e = b.match(a);
        if (e !== null) {
            if (RegExp.$1 !== "") {
                d = RegExp.$1;
                c = c.toFixed(d);
                b = b.replace(a, c);
            }
        }
        return b;
    };
    var d = function(a) {
        new c(a);
    };
    a.plot.plugins.push({
        init: d,
        options: b,
        name: "tooltip",
        version: "0.6.1"
    });
})(jQuery);

(function(a) {
    function b(a) {
        var b;
        var c;
        var d;
        var e;
        var f = 1;
        var g = false;
        var h = {};
        function i(a, d, f) {
            var g = null;
            if (j(d)) {
                q(d);
                k(a);
                m(a);
                p(d);
                if (c >= 2) {
                    var i = r(d);
                    var l = 0;
                    var n = s();
                    if (typeof h[d.bars.order] === "undefined") {
                        if (t(i)) {
                            h[d.bars.order] = -1 * u(b, i - 1, Math.floor(c / 2) - 1) - n;
                        } else {
                            h[d.bars.order] = u(b, Math.ceil(c / 2), i - 2) + n + e * 2;
                        }
                    }
                    l = h[d.bars.order];
                    g = v(f, d, l);
                    f.points = g;
                }
            }
            return g;
        }
        function j(a) {
            return a.bars != null && a.bars.show && a.bars.order != null;
        }
        function k(a) {
            var b = g ? a.getPlaceholder().innerHeight() : a.getPlaceholder().innerWidth();
            var c = g ? l(a.getData(), 1) : l(a.getData(), 0);
            var d = c[1] - c[0];
            f = d / b;
        }
        function l(a, b) {
            var c = new Array();
            for (var d = 0; d < a.length; d++) {
                c[0] = a[d].data[0][b];
                c[1] = a[d].data[a[d].data.length - 1][b];
            }
            return c;
        }
        function m(a) {
            b = n(a.getData());
            c = b.length;
        }
        function n(a) {
            var b = new Array();
            var c = [];
            for (var d = 0; d < a.length; d++) {
                if (a[d].bars.order != null && a[d].bars.show && c.indexOf(a[d].bars.order) < 0) {
                    c.push(a[d].bars.order);
                    b.push(a[d]);
                }
            }
            return b.sort(o);
        }
        function o(a, b) {
            var c = a.bars.order;
            var d = b.bars.order;
            return c < d ? -1 : c > d ? 1 : 0;
        }
        function p(a) {
            d = typeof a.bars.lineWidth !== "undefined" ? a.bars.lineWidth : 2;
            e = d * f;
        }
        function q(a) {
            if (a.bars.horizontal) {
                g = true;
            }
        }
        function r(a) {
            var c = 0;
            for (var d = 0; d < b.length; ++d) {
                if (a == b[d]) {
                    c = d;
                    break;
                }
            }
            return c + 1;
        }
        function s() {
            var a = 0;
            if (c % 2 != 0) a = b[Math.ceil(c / 2)].bars.barWidth / 2;
            return a;
        }
        function t(a) {
            return a <= Math.ceil(c / 2);
        }
        function u(a, b, c) {
            var d = 0;
            for (var f = b; f <= c; f++) {
                d += a[f].bars.barWidth + e * 2;
            }
            return d;
        }
        function v(a, b, c) {
            var d = a.pointsize;
            var e = a.points;
            var f = 0;
            for (var h = g ? 1 : 0; h < e.length; h += d) {
                e[h] += c;
                b.data[f][3] = e[h];
                f++;
            }
            return e;
        }
        a.hooks.processDatapoints.push(i);
    }
    var c = {
        series: {
            bars: {
                order: null
            }
        }
    };
    a.plot.plugins.push({
        init: b,
        options: c,
        name: "orderBars",
        version: "0.2"
    });
})(jQuery);

(function(a) {
    var b = {
        list: 0,
        table: 1
    };
    a.ui.richAutocomplete = {};
    a.extend(a.ui.richAutocomplete, {
        objectCache: function() {
            var a = {};
            return {
                get: function(b) {
                    return a[b];
                },
                put: function(b, c) {
                    a[b] = c;
                }
            };
        }
    });
    a.widget("rf.richAutocomplete", {
        LAYOUT: b,
        options: {
            token: "",
            showButton: false,
            autoFocus: false,
            autoFill: false,
            source: [],
            layout: b.list,
            minLength: 0,
            cached: false,
            extractCacheSearchPrefix: c,
            cacheImplemenation: a.ui.richAutocomplete.objectCache,
            filter: a.ui.autocomplete.filter,
            update: null,
            suggestions: []
        },
        _create: function() {
            var a = this;
            this.input = this.element;
            this.root = this._initDom();
            if (this.options.cached) {
                this.cache = new this.options.cacheImplemenation();
            }
            if (!this.options.layout) {
                this._setOption("layout", this.LAYOUT.list);
            }
            var b = this._getAutocompleteOptions();
            this.input.autocomplete(b);
            this.input.keydown(function(b) {
                a.lastKeyupEvent = b;
            });
            this._registerListeners();
            if (this.options.source) {
                this._setOption("source", this.options.source);
            }
            if (this.input.disabled) {
                this._setOption("disabled", true);
            }
        },
        _destroy: function() {
            this.input.autocomplete("destroy");
            this._destroyDom();
        },
        _enable: function() {
            this.input.autocomplete("enable");
            this.button.removeAttr("disabled");
        },
        _disable: function() {
            this.input.autocomplete("disable");
            this.button.attr("disabled", "disabled");
        },
        _initDom: function() {
            this.root = a(a('<div class="r-autocomplete"></div>').insertBefore(this.input)[0]);
            this.root.append(this.input.detach());
            if (this.options.showButton) {
                var b = this;
                this.root.addClass("input-group");
                this.button = a('<span class="input-group-btn"><button class="btn btn-light" type="button"><i class="icon-chevron-down"></button></i></span>').appendTo(this.root).find("button");
                this.buttonClickHandler = function() {
                    b.input.autocomplete("search");
                    b.input.focus();
                };
                this.button.on("click", this.buttonClickHandler);
            }
            return this.root;
        },
        _destroyDom: function() {
            this.input.detach().insertAfter(this.root);
            this.root.remove();
        },
        _getAutocompleteOptions: function() {
            var a = this;
            return {
                delay: 0,
                minLength: this.options.minLength,
                autoFocus: this.options.autoFocus,
                source: function(b, c) {
                    a._getSuggestions(b, c);
                },
                search: function() {
                    this.opened = true;
                    if (a.options.autoFill) {
                        if (a.entered === a.input.val()) {
                            return false;
                        }
                    }
                    a.entered = a.input.val();
                    if (a.button) {
                        a.button.off("click", a.buttonClickHandler);
                        a.button.find("i").removeClass("icon-chevron-down");
                        a.button.find("i").addClass("icon-chevron-up");
                    }
                },
                focus: function(b, c) {
                    if (!a.options.autoFill) {
                        return false;
                    }
                    if (a.lastKeyupEvent.keyCode == 8) {
                        return false;
                    }
                    var d = a.input, e = a.entered;
                    label = c.item.label;
                    e = e.substring(0, d[0].selectionStart);
                    if (e.length > 0 && label.toLowerCase().indexOf(e.toLowerCase()) === 0) {
                        d.val(e + label.substring(e.length));
                        d[0].selectionStart = e.length;
                        d[0].selectionEnd = label.length;
                        return false;
                    } else {
                        return true;
                    }
                },
                close: function(b) {
                    if (a.button) {
                        a.button.find("i").removeClass("icon-chevron-up");
                        a.button.find("i").addClass("icon-chevron-down");
                        setTimeout(function() {
                            a.button.on("click", a.buttonClickHandler);
                        }, 150);
                    }
                },
                select: function(b, c) {
                    this.value = a._selectValue(b, c, this.value);
                    return false;
                }
            };
        },
        _splitTokens: function(a) {
            var b = new RegExp("\\s*" + this.options.token + "\\s*");
            return a.split(b);
        },
        _extractLastToken: function(a) {
            return this._splitTokens(a).pop();
        },
        _extractSearchTerm: function(a) {
            if (this.options.token) {
                return this._extractLastToken(a.term);
            } else {
                return a.term;
            }
        },
        _selectValue: function(a, b, c) {
            if (this.options.token) {
                var d = this._splitTokens(c);
                d.pop();
                d.push(b.item.value);
                d.push("");
                return d.join(this.options.token + " ");
            } else {
                return b.item.value;
            }
        },
        _getSuggestions: function(b, c) {
            var d = this._extractSearchTerm(b);
            var e = a.extend({}, b, {
                term: d
            });
            if (this.cache) {
                e.term = this.options.extractCacheSearchPrefix.call(this, d);
            }
            var f = a.proxy(function() {
                if (this.cache) {
                    this.cache.put(d, arguments);
                }
                return c.apply(window, arguments);
            }, this);
            if (this.cache) {
                var g = this.cache.get(d);
                if (g) {
                    c.apply(window, g);
                    return;
                }
            }
            this._retrieveSuggestions(e, f);
        },
        _retrieveSuggestions: function(b, c) {
            var e = this.options.source;
            if (d(e)) {
                this._suggestFromDom(b, c);
            } else if (a.isFunction(e)) {
                e(b, c);
            } else {
                c(this.options.filter(e, b.term));
            }
        },
        _suggestFromDom: function(b, c) {
            var d = this.options.update;
            var e = a.proxy(function() {
                this._updateDomSuggestions();
                c(this.options.filter(this.options.suggestions, b.term));
            }, this);
            if (a.isFunction(d)) {
                if (d.length >= 2) {
                    d.call(window, b, e);
                } else {
                    d.call(window, b);
                    e();
                }
            } else {
                c(this.options.filter(this.options.suggestions, b.term));
            }
        },
        _updateDomSuggestions: function() {
            var c = [];
            var d = a(this.options.source);
            var e = b.list;
            if (d.is("table")) {
                e = b.table;
                d = d.children("tbody");
            }
            a(d).children("tr, li").each(function() {
                c.push({
                    value: a(this).data("label") || a(this).text(),
                    dom: a(this).clone()
                });
            });
            if (this.option("layout") !== e) {
                this._setOption("layout", e);
            }
            this._setOption("suggestions", c);
        },
        _preventTabbing: function() {
            this.element.bind("keydown", function(b) {
                if (b.keyCode === a.ui.keyCode.TAB && a(this).data("autocomplete").menu.active) {
                    b.preventDefault();
                }
            });
        },
        _registerListeners: function() {
            this.input.bind("autocompletesearch", this.options.onsearch);
            this.input.bind("autocompleteopen", this.options.onopen);
            this.input.bind("autocompletefocus", this.options.onfocus);
            this.input.bind("autocompleteselect", this.options.onselect);
            this.input.bind("autocompleteclose", this.options.onclose);
            this.input.bind("autocompletechange", this.options.onchange);
        },
        _setLayout: function(b) {
            var c = this.input.autocomplete().data("ui-autocomplete");
            switch (b) {
              case this.LAYOUT.list:
                c._renderMenu = a.ui.autocomplete.prototype._renderMenu;
                c._renderItem = function(b, c) {
                    var d = c.dom ? a("<a>").html(c.dom.children()) : a("<a>").text(c.label);
                    return a("<li>").append(d).appendTo(b);
                };
                break;

              case this.LAYOUT.table:
                this._setOption("appendTo", a("<div class='ui-autocomplete-layout-table-wrapper'>").appendTo(a("body")));
                c._renderMenu = function(b, c) {
                    b.addClass("ui-autocomplete-layout-table");
                    return a.ui.autocomplete.prototype._renderMenu.call(this, b, c);
                };
                c._renderItem = function(b, c) {
                    var d = a("<a>");
                    c.dom.find("td").each(function() {
                        a("<span>").html(a(this).html()).appendTo(d);
                    });
                    return a("<li></li>").data("item.autocomplete", c).append(d).appendTo(b);
                };
                break;
            }
        },
        _setOption: function(a, b) {
            if (a === "layout") {
                this._setLayout(b);
            }
            if (a === "disabled") {
                if (b) {
                    this._disable();
                } else {
                    this._enable();
                }
            }
            this._super(a, b);
            if (a === "source") {
                if (d(b)) {
                    this._updateDomSuggestions();
                }
            }
        }
    });
    function c(a) {
        if (a && this.options.minLength > 0 && this.options.minLength < a.length) {
            return a.substring(0, this.options.minLength);
        } else {
            return a;
        }
    }
    function d(a) {
        return a instanceof HTMLElement || typeof a == "string";
    }
})(jQuery);

(function(a) {
    a.widget("rf.chart", {
        options: {
            grid: {
                clickable: true,
                hoverable: true
            },
            tooltip: true,
            tooltipOpts: {
                content: "%s  [%x,%y]",
                shifts: {
                    x: 20,
                    y: 0
                },
                defaultTheme: false
            }
        },
        pieDefaults: {
            series: {
                pie: {
                    show: true
                }
            },
            tooltipOpts: {
                content: " %p.0%, %s",
                shifts: {
                    x: 20,
                    y: 0
                },
                defaultTheme: false
            }
        },
        dateDefaults: {
            xaxis: {
                mode: "time",
                timeformat: "%Y/%m/%d",
                minTickSize: [ 1, "day" ]
            }
        },
        _create: function() {
            this._handleTypeDependentOptions();
            this._draw();
            this._registerListeners();
        },
        _handleTypeDependentOptions: function() {
            if (this.options.charttype === "pie") {
                this.options = a.extend(this.options, this.pieDefaults);
                this.options.data = this.options.data[0];
            } else if (this.options.charttype === "bar") {
                if (this.options.xtype === "class java.lang.String") {
                    var b = [], c = [], d = true, e = 0;
                    for (index in this.options.data) {
                        var f = [];
                        var g = 0;
                        if (d) {
                            for (h in this.options.data[index].data) {
                                b.push([ g, h ]);
                                c.push(h);
                                f.push([ g, this.options.data[index].data[h] ]);
                                g++;
                            }
                            d = false;
                        } else {
                            for (k in c) {
                                var h = c[k];
                                if (this.options.data[index].data[h]) {
                                    f.push([ g, this.options.data[index].data[h] ]);
                                }
                                g++;
                            }
                        }
                        this.options.data[index].data = f;
                        var i = {
                            order: e,
                            show: true
                        };
                        this.options.data[index].bars = i;
                        e++;
                    }
                    this.options.xaxis = a.extend(this.options.xaxis, {
                        ticks: b,
                        tickLength: 0,
                        tickFormatter: function(a, b) {
                            return b.ticks[a].label;
                        }
                    });
                    this.options.bars = a.extend(this.options.bars, {
                        show: true,
                        barWidth: .2,
                        align: "center"
                    });
                }
            } else if (this.options.charttype === "line") {
                if (this.options.zoom) {
                    this.options.selection = {
                        mode: "xy"
                    };
                }
                if (this.options.xtype === "class java.util.Date") {
                    this.options = a.extend(this.options, this.dateDefaults);
                    if (this.options.xaxis.format) {
                        this.options.xaxis.timeformat = this.options.xaxis.format;
                    }
                }
            }
        },
        _setOption: function(b, c) {
            a.Widget.prototype._setOption.apply(this, arguments);
            this._super("_setOption", b, c);
            var d = true;
            switch (b) {
              case "zoom":
              case "handlers":
              case "particularSeriesHandlers":
                this._unbind();
                this._registerListeners();
                d = false;
                break;
            }
            if (d) {
                this._draw();
            }
        },
        _draw: function(b) {
            if (b) {
                this.plot = a.plot(this.element, b.data, b);
            } else {
                this.plot = a.plot(this.element, this.options.data, this.options);
            }
        },
        _registerListeners: function() {
            if (this.options.zoom) {
                this.element.bind("plotselected", this._getZoomFunction(this, this.element, this.options));
            }
            this.element.bind("plotclick", this._getPlotClickHandler(this.options, this.element));
            this.element.bind("plothover", this._getPlotHoverHandler(this.options, this.element));
            if (this.options.handlers && this.options.handlers.onmouseout) {
                this.element.bind("mouseout", this.options.handlers.onmouseout);
            }
        },
        _getPlotClickHandler: function(a, b) {
            return function(c, d, e) {
                if (e !== null) {
                    c.data = {
                        seriesIndex: e.seriesIndex,
                        dataIndex: e.dataIndex,
                        x: e.datapoint[0],
                        y: e.datapoint[1],
                        item: e
                    };
                    a.handlers.eventFunction(c, "plotclick", c.data.seriesIndex, c.data.dataIndex, c.data.x, c.data.y);
                    if (a.handlers && a.handlers["onplotclick"]) {
                        a.handlers["onplotclick"].call(b, c);
                    }
                    if (a.particularSeriesHandlers && a.particularSeriesHandlers["onplotclick"][c.data.seriesIndex]) {
                        a.particularSeriesHandlers["onplotclick"][c.data.seriesIndex].call(b, c);
                    }
                }
            };
        },
        _getPlotHoverHandler: function(a, b) {
            return function(c, d, e) {
                if (e !== null) {
                    c.data = {
                        seriesIndex: e.seriesIndex,
                        dataIndex: e.dataIndex,
                        x: e.datapoint[0],
                        y: e.datapoint[1],
                        item: e
                    };
                    if (a.handlers && a.handlers["onplothover"]) {
                        a.handlers["onplothover"].call(b, c);
                    }
                    if (a.particularSeriesHandlers && a.particularSeriesHandlers["onplothover"][c.data.seriesIndex]) {
                        a.particularSeriesHandlers["onplothover"][c.data.seriesIndex].call(b, c);
                    }
                }
            };
        },
        _getZoomFunction: function(b, c, d) {
            return function(c, d) {
                if (d.xaxis.to - d.xaxis.from < 1e-5) {
                    d.xaxis.to = d.xaxis.from + 1e-5;
                }
                if (d.yaxis.to - d.yaxis.from < 1e-5) {
                    d.yaxis.to = d.yaxis.from + 1e-5;
                }
                b._draw(a.extend({}, b.options, {
                    xaxis: {
                        min: d.xaxis.from,
                        max: d.xaxis.to
                    },
                    yaxis: {
                        min: d.yaxis.from,
                        max: d.yaxis.to
                    }
                }));
            };
        },
        resetZoom: function() {
            this._draw();
        },
        getPlotObject: function() {
            return this.plot;
        },
        _unbind: function() {
            this.element.unbind("plotclick");
            this.element.unbind("plothover");
            this.element.unbind("plotselected");
            this.element.unbind("mouseout");
        },
        destroy: function() {
            this.plot.shutDown();
            this._unbind();
            a.Widget.prototype.destroy.call(this);
        }
    });
})(jQuery);

(function(a) {
    a.widget("rf.orderingList", {
        options: {
            disabled: false,
            header: undefined,
            height: undefined,
            heightMin: undefined,
            heightMax: undefined,
            styleClass: undefined,
            columnClasses: undefined,
            showButtons: true,
            buttonsText: undefined,
            contained: true,
            dragSelect: false,
            dropOnEmpty: true,
            mouseOrderable: true,
            widgetEventPrefix: "orderinglist_",
            change: null,
            addDomElements: null,
            destroy: null,
            focus: null,
            blur: null,
            change: null
        },
        _create: function() {
            var b = this;
            this.selectableOptions = {
                disabled: b.options.disabled
            };
            this.sortableOptions = {
                handle: this.options.dragSelect ? ".handle" : false,
                disabled: this.options.disabled,
                dropOnEmpty: this.options.dropOnEmpty,
                scroll: true,
                placeholder: "placeholder",
                tolerance: "pointer",
                start: function(a, c) {
                    b.currentItems = c.item.parent().children(".ui-selected").not(".placeholder").not(".helper-item");
                    var d = c.helper;
                    var e = b.element.find(".placeholder");
                    e.css("height", d.css("height"));
                    b.currentItems.not(c.item).hide();
                },
                sort: function(b, c) {
                    var d = a(this);
                    var e = c.helper.position().top, f = e + c.helper.outerHeight();
                    d.children(".ui-selectee").not(".placeholder").not(".helper-item").not(".ui-selected").each(function() {
                        var b = a(this);
                        var c = b.position().top;
                        var g = b.position().top + b.outerHeight() / 2;
                        if (e < g && g < f) {
                            if (c > e) {
                                a(".placeholder", d).insertAfter(b);
                            } else {
                                a(".placeholder", d).insertBefore(b);
                            }
                            return false;
                        }
                    });
                },
                cancel: function(a, c) {
                    b.currentItems.show();
                },
                over: function(a, c) {
                    if (b.fillItem) {
                        b._updateFillRow();
                    }
                },
                beforeStop: function(a, b) {},
                stop: function(a, c) {
                    var d = b.currentItems.first();
                    if (d.get(0) !== c.item.get(0)) {
                        c.item.before(d);
                        d.after(b.currentItems.not(d).detach());
                    } else {
                        c.item.after(b.currentItems.not(c.item).detach());
                    }
                    b.currentItems.not(".placeholder").show();
                    var c = b._dumpState();
                    c.movement = "drag";
                    if (b.fillItem) {
                        b._updateFillRow();
                    }
                    b._trigger("change", a, c);
                }
            };
            if (this.element.is("table")) {
                this.strategy = "table";
                this.$pluginRoot = this.element.find("tbody");
                this.sortableOptions.items = "tr:not(.fill-item)";
                this.selectableOptions.filter = "tr:not(.fill-item)";
                this.sortableOptions.helper = a.proxy(this._rowHelper, this);
            } else {
                this.strategy = "list";
                this.$pluginRoot = this.element;
                this.selectableOptions.filter = "li";
                this.sortableOptions.helper = a.proxy(this._listHelper, this);
            }
            if (this.options.contained !== false) {
                this.sortableOptions.containment = this.$pluginRoot;
                this.sortableOptions.axis = "y";
            }
            this._addDomElements();
            this.widgetEventPrefix = this.options.widgetEventPrefix;
            if (this.options.mouseOrderable === true) {
                this.$pluginRoot.sortable(this.sortableOptions);
            }
            this.$pluginRoot.selectable(this.selectableOptions);
            if (this.options.disabled === true) {
                b._disable();
            }
            var c = ".handle";
            this._addDragListeners();
            this.selectList.on("focusin", function(a) {
                b._trigger("focus", a, b._dumpState());
            });
            this.selectList.on("focusout", function(a) {
                b._trigger("blur", a, b._dumpState());
            });
            if (typeof this.options.height !== "undefined") {
                this._setHeight(this.options.height);
            }
            if (typeof this.options.heightMin !== "undefined") {
                this._setHeightMin(this.options.heightMin);
            }
            if (typeof this.options.heightMax !== "undefined") {
                this._setHeightMax(this.options.heightMax);
            }
            this._trigger("create", undefined, this._dumpState());
        },
        destroy: function() {
            a.Widget.prototype.destroy.call(this);
            this.$pluginRoot.sortable("destroy").selectable("destroy");
            this._removeDomElements();
            if (!this.element.attr("class")) {
                this.element.removeAttr("class");
            }
            if (this.strategy === "table") {
                this.element.children().each(function() {
                    var b = a(this);
                    if (!b.attr("class")) {
                        b.removeAttr("class");
                    }
                    b.children().each(function() {
                        var b = a(this);
                        if (!b.attr("class")) {
                            b.removeAttr("class");
                        }
                        b.children().each(function() {
                            var b = a(this);
                            if (!b.attr("class")) {
                                b.removeAttr("class");
                            }
                        });
                    });
                });
            } else {
                this.element.children().each(function() {
                    var b = a(this);
                    if (!b.attr("class")) {
                        b.removeAttr("class");
                    }
                });
            }
            this._trigger("destroy", undefined, {});
        },
        _addDragListeners: function() {
            var b = this;
            if (this.options.dragSelect == false) {
                this.element.on("mousedown", ".ui-selectee", function(c) {
                    var d = a(this);
                    if (b.selectList.get(0) !== document.activeElement) {
                        b.selectList.focus();
                    }
                    var e = d.parents(".list").first();
                    e.data("rfOrderingList").mouseStarted = true;
                });
                this.$pluginRoot.on("mousemove", ".ui-selectee", function(b) {
                    var c = a(this);
                    var d = c.parents(".list").first();
                    var e = d.data("rfOrderingList");
                    if (e.mouseStarted) {
                        e.mouseStarted = false;
                        if (!c.hasClass("ui-selected")) {
                            var f = e.$pluginRoot.data("uiSelectable");
                            f._mouseStart(b);
                            f._mouseStop(b);
                        }
                    }
                });
                this.element.on("mouseup", ".ui-selectee", function(b) {
                    var c = a(this);
                    var d = c.parents(".list").first();
                    var e = d.data("rfOrderingList");
                    if (e.mouseStarted) {
                        e.mouseStarted = false;
                        var f = e.$pluginRoot.data("uiSelectable");
                        f._mouseStart(b);
                        f._mouseStop(b);
                    }
                });
            } else {
                this.element.find(".handle").on("mousedown", function(b) {
                    var c = a(this).parents(".ui-selectee").first();
                    if (!c.hasClass("ui-selected")) {
                        var d = c.parents(".list").first();
                        var e = d.data("rfOrderingList").$pluginRoot.data("uiSelectable");
                        e._mouseStart(b);
                        e._mouseStop(b);
                    }
                });
            }
        },
        _removeDragListeners: function() {
            if (this.options.dragSelect == false) {
                this.element.off("mousedown", ".ui-selectee");
                this.element.off("mousemove", ".ui-selectee");
                this.element.off("mouseup", ".ui-selectee");
            } else {
                this.element.find(".handle").off("mousedown");
            }
        },
        _listHelper: function(b, c) {
            var d = a("<ol />").addClass("helper").css("height", "auto").css("width", this.element.css("width"));
            c.parent().children(".ui-selected").not(".ui-sortable-placeholder").clone().addClass("helper-item").show().appendTo(d);
            return d;
        },
        _rowHelper: function(b, c) {
            var d = a("<div />").addClass("helper").css("height", "auto");
            c.parent().children(".ui-selected").not(".ui-sortable-placeholder").clone().addClass("helper-item").show().appendTo(d);
            var e = d.children("tr").first();
            e.children().each(function(b) {
                var d = c.children().get(b);
                var e = a(d).css("width");
                a(this).css("width", e);
            });
            return d;
        },
        _setOption: function(b, c) {
            var d = this;
            if (this.options.key === c) {
                return;
            }
            switch (b) {
              case "disabled":
                if (c === true) {
                    d._disable();
                } else {
                    d._enable();
                }
                break;

              case "header":
                if (!d.header) {
                    d._addHeader();
                }
                d.header.text(c);
                break;

              case "height":
                d._setHeight(c);
                break;

              case "heightMin":
                d._setHeightMin(c);
                break;

              case "heightMax":
                d._setHeightMax(c);
                break;

              case "columnClasses":
                if (d.options.columnClasses) {
                    d._removeColumnClasses(d.options.columnClasses);
                }
                d._addColumnClasses(c);
                break;

              case "styleClass":
                if (d.options.styleClass) {
                    d.selectList.removeClass(this.options.styleClass);
                }
                d.selectList.addClass(c);
                break;

              case "buttonsText":
                this._applyButtonsText(this.selectList.find(".btn-group-vertical"), c);
                break;
            }
            a.Widget.prototype._setOption.apply(d, arguments);
        },
        _createKeyArray: function(b) {
            var c = new Array();
            b.each(function() {
                var b = a(this);
                var d = b.data("key");
                var e = typeof d !== "undefined" ? d : b.text();
                c.push(e);
            });
            return c;
        },
        connectWith: function(b) {
            if (!this.options.mouseOrderable) {
                return;
            }
            var c = b.data("rfOrderingList");
            this.$pluginRoot.sortable("option", "connectWith", c.$pluginRoot);
            this._addFillRow();
            b.on("sortover", a.proxy(this._updateFillRow, this));
        },
        isSelected: function(b) {
            return a(b).hasClass("ui-selected");
        },
        getSelected: function() {
            return this.element.find(".ui-selected");
        },
        selectItem: function(b) {
            a(b).addClass("ui-selected");
        },
        unSelectItem: function(b) {
            a(b).removeClass("ui-selected");
        },
        unSelectAll: function() {
            var a = this;
            this._removeDomElements();
            this.element.children().each(function() {
                a.unSelectItem(this);
            });
        },
        moveTop: function(b, c) {
            if (this.options.disabled) return;
            var d = b.prevAll().not(".ui-selected").last();
            a(b).insertBefore(d);
            var e = this._dumpState();
            e.movement = "moveTop";
            this._trigger("change", c, e);
        },
        moveUp: function(b, c) {
            if (this.options.disabled) return;
            a(b).each(function() {
                var b = a(this);
                var c = b.prevAll().not(".ui-selected").first();
                if (c.length > 0) {
                    b.insertBefore(c);
                }
            });
            var d = this._dumpState();
            d.movement = "moveUp";
            this._trigger("change", c, d);
        },
        moveDown: function(b, c) {
            if (this.options.disabled) return;
            a(b).sort(function() {
                return 1;
            }).each(function() {
                var b = a(this);
                var c = b.nextAll().not(".ui-selected").first();
                if (c.length > 0) {
                    b.insertAfter(c);
                }
            });
            var d = this._dumpState();
            d.movement = "moveDown";
            this._trigger("change", c, d);
        },
        moveLast: function(b, c) {
            if (this.options.disabled) return;
            var d = b.nextAll().not(".ui-selected").last();
            a(b).insertAfter(d);
            var e = this._dumpState();
            e.movement = "moveLast";
            this._trigger("change", c, e);
        },
        remove: function(a) {
            a.detach();
            var b = this._dumpState();
            b.movement = "remove";
            this._trigger("change", event, b);
            return a;
        },
        add: function(a) {
            this.$pluginRoot.prepend(a);
            var b = this._dumpState();
            b.movement = "add";
            this._trigger("change", event, b);
            return a;
        },
        getOrderedElements: function() {
            return this.element.find(".ui-selectee");
        },
        getOrderedKeys: function() {
            return this._createKeyArray(this.getOrderedElements());
        },
        _addDomElements: function() {
            this._addParents();
            this._addMouseHandles();
            if (this.options.showButtons === true) {
                this._addButtons();
            }
            if (this.strategy === "table") {
                var b = this;
                this.element.find("tr").each(function() {
                    var c = a(this);
                    var d = c.children();
                    d.last().addClass("last");
                    d.first().addClass("first");
                    if (b.options.columnClasses) {
                        b._addColumnClassesToCells(d, b.options.columnClasses);
                    }
                });
            }
            this._trigger("addDomElements", undefined, this._dumpState());
        },
        _addColumnClasses: function(b) {
            if (this.strategy !== "table") {
                return;
            }
            var c = this;
            this.element.find("tr").each(function() {
                c._addColumnClassesToCells(a(this).children(), b);
            });
        },
        _addColumnClassesToCells: function(b, c) {
            var c = c.split(" ");
            b.each(function(b) {
                if (b < c.length) {
                    a(this).addClass(c[b]);
                } else {
                    return false;
                }
            });
        },
        _addButtons: function() {
            var b = a("<div/>").addClass("btn-group-vertical");
            this._addButton(b, "first", "icon-arrow-up", a.proxy(this._firstHandler, this));
            this._addButton(b, "up", "icon-arrow-up", a.proxy(this._upHandler, this));
            this._addButton(b, "down", "icon-arrow-down", a.proxy(this._downHandler, this));
            this._addButton(b, "last", "icon-arrow-down", a.proxy(this._lastHandler, this));
            if (this.options.buttonsText) {
                this._applyButtonsText(b, this.options.buttonsText);
            }
            this.content.append(a("<div />").addClass("button-column").append(b));
        },
        _applyButtonsText: function(a, b) {
            this._applyButtonText(a.find(".btn-first"), b.first);
            this._applyButtonText(a.find(".btn-up"), b.up);
            this._applyButtonText(a.find(".btn-down"), b.down);
            this._applyButtonText(a.find(".btn-last"), b.last);
        },
        _applyButtonText: function(b, c) {
            if (!c) {
                if (b.hasClass("labeled")) {
                    b.removeClass("labeled");
                    b.find("span").remove();
                }
                return;
            }
            if (b.hasClass("labeled")) {
                b.find("span").text(c);
            } else {
                b.addClass("labeled").append(a("<span />").text(c));
            }
        },
        _addButton: function(b, c, d, e) {
            var f = a("<button/>").attr("type", "button").addClass("btn btn-default").addClass("btn-" + c).on("click.orderingList", e).append(a("<i />").addClass("icon icon-" + c));
            b.append(f);
        },
        _addMouseHandles: function() {
            if (this.options.mouseOrderable !== true) {
                return;
            }
            if (this.options.dragSelect === true) {
                this.content.addClass("with-handle");
                if (this.strategy === "table") {
                    this.element.find("tbody > tr").prepend("<th class='handle'><i class='icon-move'></i></th>");
                    this.element.find("thead > tr").prepend("<th class='handle'></th>");
                } else if (this.strategy === "list") {
                    this.element.find("li").prepend("<div class='handle'><i class='icon-move'></i></div>");
                }
            }
        },
        _addParents: function() {
            this.element.addClass("list").wrap(a("<div />").addClass("ordering-list select-list").attr("tabindex", -1).append(a("<div />").addClass("content").append(a("<div />").addClass("scroll-box"))));
            this.selectList = this.element.parents(".select-list").first();
            if (this.options.styleClass) {
                this.selectList.addClass(this.options.styleClass);
            }
            if (this.options.header) {
                this._addHeader();
            }
            this.content = this.selectList.find(".content");
        },
        _addHeader: function() {
            var b = a("<div />").addClass("header");
            b.html(this.options.header);
            this.selectList.prepend(b);
            this.header = b;
        },
        _addFillRow: function() {
            var b = this.$pluginRoot.sortable("option", "connectWith");
            if (!b || this.strategy != "table") {
                return;
            }
            var c = this.$pluginRoot.sortable("option", "items");
            var d = this.$pluginRoot.find(c);
            if (d.length > 0) {
                var e = d.first();
            } else {
                var f = a(b).find("tr");
                if (f.length > 0) {
                    e = f.first();
                }
            }
            if (e) {
                var g = e.clone();
                g.removeClass().addClass("fill-item").removeClass("ui-selectee");
                g.find("td").empty();
                g.data("key", undefined);
                this.$pluginRoot.append(g);
                this.fillItem = g;
                this.element.on(this.options.widgetEventPrefix + "change", a.proxy(this._updateFillRow, this));
            }
            this._updateFillRow();
        },
        _updateFillRow: function() {
            if (this.fillItem) {
                this.fillItem.css("height", "0");
                var a = this.fillItem.parents("table").first();
                var b = this.fillItem.parents("tbody").first();
                var c = this.fillItem.parents(".scroll-box").first();
                this.fillItem.detach();
                var d = c.height() - a.height();
                var e = this.element.find(".placeholder");
                if (e) {
                    d = d - e.height();
                }
                this.fillItem.height(d);
                this.fillItem.toggle(d > 2);
                b.append(this.fillItem);
            }
        },
        _setHeight: function(a) {
            this.selectList.find(".scroll-box").css("height", a);
        },
        _setHeightMin: function(a) {
            this.selectList.find(".scroll-box").css("min-height", a);
        },
        _setHeightMax: function(a) {
            this.selectList.find(".scroll-box").css("max-height", a);
        },
        _disable: function() {
            this.$pluginRoot.sortable("option", "disabled", true).selectable("option", "disabled", true);
            this.element.addClass("disabled").find(".ui-selected").removeClass("ui-selected");
            this.element.find(".ui-selectee").removeClass("ui-selectee").addClass("ui-disabled");
            a(".button-column", this.content).find("button").attr("disabled", true);
            this._removeDragListeners();
        },
        _enable: function() {
            this.$pluginRoot.sortable("option", "disabled", false).selectable("option", "disabled", false);
            this.element.removeClass("disabled");
            this.element.find(".ui-disabled").removeClass("ui-disabled").addClass("ui-selectee");
            a(".button-column", this.content).find("button").attr("disabled", false);
            this._addDragListeners();
        },
        _dumpState: function() {
            var a = {};
            a.orderedElements = this.getOrderedElements();
            a.orderedKeys = this.getOrderedKeys();
            return a;
        },
        _removeDomElements: function() {
            this.element.find(".ui-selected").removeClass("ui-selected");
            if (this.strategy === "table") {
                var b = this;
                this.element.find("tr").each(function() {
                    var c = a(this);
                    var d = c.children();
                    d.last().removeClass("last");
                    d.first().removeClass("first");
                    if (b.options.columnClasses) {
                        b._removeColumnClassesFromCells(d, b.options.columnClasses);
                    }
                });
                if (this.fillItem) {
                    this.element.find(".fill-item").remove();
                }
            }
            var c = this.element.detach();
            this.selectList.replaceWith(c);
            if (this.options.dragSelect === true) {
                this.content.removeClass("with-handle");
                this.element.find(".handle").remove();
            }
            this.element.removeClass("list");
        },
        _removeColumnClasses: function(b) {
            if (this.strategy !== "table") {
                return;
            }
            var c = this;
            this.element.find("tr").each(function() {
                c._removeColumnClassesFromCells(a(this).children(), b);
            });
        },
        _removeColumnClassesFromCells: function(b, c) {
            var c = c.split(" ");
            b.each(function(b) {
                if (b < c.length) {
                    a(this).removeClass(c[b]);
                } else {
                    return false;
                }
            });
        },
        _firstHandler: function(b) {
            this.moveTop(a(".ui-selected", this.element), b);
        },
        _upHandler: function(b) {
            this.moveUp(a(".ui-selected", this.element), b);
        },
        _downHandler: function(b) {
            this.moveDown(a(".ui-selected", this.element), b);
        },
        _lastHandler: function(b) {
            this.moveLast(a(".ui-selected", this.element), b);
        }
    });
})(jQuery);

(function(a) {
    a.widget("rf.pickList", {
        options: {
            disabled: false,
            header: undefined,
            height: undefined,
            heightMin: undefined,
            heightMax: undefined,
            styleClass: undefined,
            columnClasses: undefined,
            sourceHeader: undefined,
            targetHeader: undefined,
            switchByClick: undefined,
            switchByDblClick: undefined,
            orderable: true,
            orderButtonsText: undefined,
            pickButtonsText: undefined,
            widgetEventPrefix: "picklist_",
            change: null,
            addDomElements: null,
            destroy: null,
            focus: null,
            blur: null,
            change: null
        },
        _create: function() {
            var a = this;
            this.widgetEventPrefix = this.options.widgetEventPrefix;
            this.sourceList = this.element.find(".source");
            this.targetList = this.element.find(".target");
            this._addDomElements();
            this.sourceList.orderingList({
                showButtons: false,
                mouseOrderable: this.options.orderable,
                contained: false,
                columnClasses: this.options.columnClasses,
                disabled: this.options.disabled,
                header: this.options.sourceHeader,
                widgetEventPrefix: "sourcelist_"
            });
            this.targetList.orderingList({
                showButtons: this.options.orderable,
                mouseOrderable: this.options.orderable,
                contained: false,
                columnClasses: this.options.columnClasses,
                buttonsText: this.options.orderButtonsText,
                disabled: this.options.disabled,
                header: this.options.targetHeader,
                widgetEventPrefix: "targetlist_"
            });
            if (this.options.orderable) {
                this.sourceList.orderingList("connectWith", this.targetList);
                this.targetList.orderingList("connectWith", this.sourceList);
            }
            this._registerListeners();
            if (this.options.disabled === true) {
                this._disable();
            }
            if (typeof this.options.height !== "undefined") {
                this._setHeight(this.options.height);
            }
            if (typeof this.options.heightMin !== "undefined") {
                this._setHeightMin(this.options.heightMin);
            }
            if (typeof this.options.heightMax !== "undefined") {
                this._setHeightMax(this.options.heightMax);
            }
            this._trigger("create", undefined, this._dumpState());
        },
        destroy: function() {
            a.Widget.prototype.destroy.call(this);
            this._unregisterListeners();
            this.sourceList.orderingList("destroy");
            this.targetList.orderingList("destroy");
            this._removeDomElements();
            this.element.removeClass("inner").removeClass("row");
            if (!this.element.attr("class")) {
                this.element.removeAttr("class");
            }
            this._trigger("destroy", undefined, {});
            return this;
        },
        removeItems: function(a, b) {
            if (this.options.disabled) return;
            this.targetList.orderingList("remove", a);
            this.sourceList.orderingList("add", a);
            var c = this._dumpState();
            c.change = "remove";
            this._trigger("change", b, c);
        },
        addItems: function(a, b) {
            if (this.options.disabled) return;
            this.sourceList.orderingList("remove", a);
            this.targetList.orderingList("add", a);
            var c = this._dumpState();
            c.change = "add";
            this._trigger("change", b, c);
        },
        _setOption: function(b, c) {
            var d = this;
            if (this.options.key === c) {
                return;
            }
            switch (b) {
              case "disabled":
                if (c === true) {
                    d._disable();
                } else {
                    d._enable();
                }
                break;

              case "header":
                if (!d.options.header) {
                    d._addHeader(c);
                }
                d.outer.find(".header-row .header").text(c);
                break;

              case "height":
                d._setHeight(c);
                break;

              case "heightMin":
                d._setHeightMin(c);
                break;

              case "heightMax":
                d._setHeightMax(c);
                break;

              case "sourceHeader":
                if (!d.options.sourceHeader) {
                    d._addSubHeader(c, this.options.targetHeader);
                }
                d.outer.find(".sub-header-row .source").text(c);
                break;

              case "targetHeader":
                if (!d.options.targetHeader) {
                    d._addSubHeader(c, this.options.targetHeader);
                }
                d.outer.find(".sub-header-row .target").text(c);
                break;

              case "styleClass":
                if (d.options.styleClass) {
                    d.outer.removeClass(d.options.styleClass);
                }
                d.outer.addClass(c);
                break;

              case "columnClasses":
                d.sourceList.orderingList("option", "columnClasses", c);
                d.targetList.orderingList("option", "columnClasses", c);
                break;

              case "orderButtonsText":
                d.targetList.orderingList("option", "buttonsText", c);
                break;

              case "buttonsText":
                this._applyButtonsText(this.outer.find(".middle .btn-group-vertical"), c);
                break;

              case "switchByClick":
                if (c === true) {
                    d._addClickListeners();
                } else {
                    d._removeClickListeners();
                }
                break;

              case "switchByDblClick":
                if (c === true) {
                    d._addDoubleClickListeners();
                } else {
                    d._removeDoubleClickListeners();
                }
                break;
            }
            a.Widget.prototype._setOption.apply(d, arguments);
        },
        _addDomElements: function() {
            this._addParents();
            var b = a("<div />").addClass("middle button-column col-sm-1");
            b.append(this._buttonStack());
            this.sourceList.parent().after(b);
            this._trigger("addDomElements", undefined, {});
        },
        _buttonStack: function() {
            var b = a('<button type="button" class="btn btn-default"/>');
            var c = a("<div/>").addClass("btn-group-picklist");
            c.append(b.clone().addClass("btn-remove-all col-sm-12 col-xs-3").html('<i class="icon icon-left-all" />').on("click.pickList", a.proxy(this._removeAllHandler, this))).append(b.clone().addClass("btn-remove col-sm-12 col-xs-3").html('<i class="icon icon-left" />').on("click.pickList", a.proxy(this._removeHandler, this))).append(b.clone().addClass("btn-add col-sm-12 col-xs-3").html('<i class="icon icon-right" />').on("click.pickList", a.proxy(this._addHandler, this))).append(b.clone().addClass("btn-add-all col-sm-12 col-xs-3").html('<i class="icon icon-right-all" />').on("click.pickList", a.proxy(this._addAllHandler, this)));
            if (this.options.pickButtonsText) {
                this._applyButtonsText(c, this.options.pickButtonsText);
            }
            return c;
        },
        _applyButtonsText: function(a, b) {
            this._applyButtonText(a.find(".btn-add-all"), b.addAll);
            this._applyButtonText(a.find(".btn-add"), b.add);
            this._applyButtonText(a.find(".btn-remove"), b.remove);
            this._applyButtonText(a.find(".btn-remove-all"), b.removeAll);
        },
        _applyButtonText: function(b, c) {
            if (!c) {
                if (b.hasClass("labeled")) {
                    b.removeClass("labeled");
                    b.find("span").remove();
                }
                return;
            }
            if (b.hasClass("labeled")) {
                b.find("span").text(c);
            } else {
                b.addClass("labeled").append(a("<span />").text(c));
            }
        },
        _addParents: function() {
            this.element.addClass("row inner").wrap(a("<div />").addClass("container pick-list outer"));
            this.outer = this.element.parents(".outer").first();
            if (this.options.styleClass) {
                this.outer.addClass(this.options.styleClass);
            }
            if (this.options.header) {
                this._addHeader(this.options.header);
            }
            if (this.options.sourceHeader || this.options.targetHeader) {
                this._addSubHeader(this.options.sourceHeader, this.options.targetHeader);
            }
            this.sourceList.wrap(a("<div />").addClass("source-wrapper col-sm-5"));
            this.targetList.wrap(a("<div />").addClass("target-wrapper col-sm-6"));
            this.content = this.element;
            this.outer.attr("tabindex", "-1");
        },
        _addSubHeader: function(b, c) {
            if (b || c) {
                var d = a("<div />").addClass("row sub-header-row");
                var b = a("<div />").addClass("col-sm-5 source header").html(b);
                var c = a("<div />").addClass("col-sm-6 col-sm-offset-1 target header").html(c);
                d.append(b).append(c);
                var e = this.outer.find(".header-row");
                if (e.length !== 0) {
                    d.insertAfter(e);
                } else {
                    this.outer.prepend(d);
                }
            }
        },
        _addHeader: function(b) {
            this.header = c;
            if (b) {
                var c = a("<div />").addClass("row header-row");
                var b = a("<div />").addClass("col-xs-12 header").html(b);
                c.append(b);
                var d = this.outer.find(".sub-header-row");
                if (d.length !== 0) {
                    c.insertBefore(d);
                } else {
                    this.outer.prepend(c);
                }
            }
        },
        _setHeight: function(a) {
            this.sourceList.orderingList("option", "height", a);
            this.targetList.orderingList("option", "height", a);
        },
        _setHeightMin: function(a) {
            this.sourceList.orderingList("option", "heightMin", a);
            this.targetList.orderingList("option", "heightMin", a);
        },
        _setHeightMax: function(a) {
            this.sourceList.orderingList("option", "heightMax", a);
            this.targetList.orderingList("option", "heightMax", a);
        },
        _registerListeners: function() {
            var a = this;
            this.sourceList.on("sortreceive", function(b, c) {
                var d = a._dumpState();
                d.change = "remove";
                d.originalEvent = b;
                a._trigger("change", b, d);
            });
            this.targetList.on("sortreceive", function(b, c) {
                var d = a._dumpState();
                d.change = "add";
                d.originalEvent = b;
                a._trigger("change", b, d);
            });
            this.targetList.on("targetlist_change", function(b, c) {
                var d = a._dumpState();
                d.change = "sort";
                d.originalEvent = b;
                a._trigger("change", b, d);
            });
            if (this.options.switchByClick) {
                this._addClickListeners();
            }
            if (this.options.switchByDblClick) {
                this._addDoubleClickListeners();
            }
            this.outer.on("focusin.picklist", function(b) {
                a._trigger("focus", b, a._dumpState());
            });
            this.outer.on("focusout.picklist", function(b) {
                a._trigger("blur", b, a._dumpState());
            });
        },
        _unregisterListeners: function() {
            this.outer.off("focusin.picklist");
            this.outer.off("focusout.picklist");
        },
        _addClickListeners: function() {
            var b = this;
            this.sourceList.on("click.pickList", ".ui-selectee", function(c) {
                b.addItems(a(this), c);
            });
            this.targetList.on("click.pickList", ".ui-selectee", function(c) {
                b.removeItems(a(this), c);
            });
        },
        _removeClickListeners: function() {
            this.sourceList.off("click.picklist", ".ui-selectee");
            this.targetList.off("click.picklist", ".ui-selectee");
        },
        _addDoubleClickListeners: function() {
            var b = this;
            this.sourceList.on("dblclick.pickList", ".ui-selectee", function(c) {
                b.addItems(a(this), c);
            });
            this.targetList.on("dblclick.pickList", ".ui-selectee", function(c) {
                b.removeItems(a(this), c);
            });
        },
        _removeDoubleClickListeners: function() {
            this.sourceList.off("dblclick.picklist", ".ui-selectee");
            this.targetList.off("dblclick.picklist", ".ui-selectee");
        },
        _disable: function() {
            this.sourceList.orderingList("option", "disabled", true);
            this.targetList.orderingList("option", "disabled", true);
            this.element.addClass("disabled");
            this.outer.find(".button-column button").attr("disabled", true);
        },
        _enable: function() {
            this.sourceList.orderingList("option", "disabled", false);
            this.targetList.orderingList("option", "disabled", false);
            this.element.removeClass("disabled");
            this.outer.find(".button-column button").attr("disabled", false);
            this._registerListeners();
        },
        _dumpState: function() {
            var a = {};
            a.pickedElements = this.targetList.orderingList("getOrderedElements");
            a.pickedKeys = this.targetList.orderingList("getOrderedKeys");
            return a;
        },
        _removeDomElements: function() {
            this.sourceList.parents(".source-wrapper").first().replaceWith(this.sourceList.detach());
            this.targetList.parents(".target-wrapper").first().replaceWith(this.targetList.detach());
            this.element.find(".middle").remove();
            var a = this.element.detach();
            this.outer.replaceWith(a);
        },
        _removeAllHandler: function(b) {
            var c = a(".ui-selectee", this.targetList);
            this.removeItems(c, b);
            this.sourceList.orderingList("selectItem", c);
        },
        _removeHandler: function(b) {
            this.removeItems(a(".ui-selected", this.targetList), b);
        },
        _addHandler: function(b) {
            this.addItems(a(".ui-selected", this.sourceList), b);
        },
        _addAllHandler: function(b) {
            var c = a(".ui-selectee", this.sourceList);
            this.addItems(c, b);
            this.targetList.orderingList("selectItem", c);
        }
    });
})(jQuery);